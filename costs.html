<html id="html">
    <head>
        <title>Google Docs</title>
        <link rel="shortcut icon" href="https://ssl.gstatic.com/docs/documents/images/kix-favicon7.ico"> <!-- Google Docs's icon -->
        <style>
            html {
                color: white;
                background: #222;
                font-family: monospace;
            }
            button {
                border: 2px solid lime;
                margin: 1px;
                cursor: pointer;
                color: lime;
                background: black;
                font-family: monospace;
                transition: 0.3s ease;
                border-radius: 3px;
            }
            .nonbutton {border: 2px solid green; color: green;}
            .Attack {border: 2px solid red; color: red;}
            .Skill {border: 2px solid skyblue; color: skyblue;}
            .Power {border: 2px solid yellow; color: yellow;}
            .Status {border: 2px solid lightgreen; color: lightgreen;}
            .unplayable {border: 2px solid #555; color: #555;}
            button:hover:not(.unplayable) {background-color: #444;}
            button:hover > span {font-size: 13px;}
            table {width: 100%;}
            .tt {user-select: none;}
            .txt {
                position: absolute;
                background: #888;
                color: black;
                display: none;
                text-align: left;
                border-radius: 5px;
                margin-left: 10px;
                padding: 5px;
            }
            .tt:hover > .txt {display: inline;}
            #energy, #player {display: inline;}
            #energy {
                border: 2px solid black;
                border-radius: 20px;
                padding: 3px;
                color: black;
                background: yellow;
            }
            #playerTd {width: 750px;}
            #rewardsScreen {text-align: center; width: 100%;}
            #rewardsScreen > button {text-align: center; width: 100%; border: none;}
            #mapScreen {margin-left: 42%; width: 58%;}
            .attacking::before { content: url(StS/intent-attack.png); }
            .bigattack::before { content: url(StS/intent-bigattack.png); }
            .blocking::before { content: url(StS/intent-block.png); }
            .buffing::before { content: url(StS/intent-buff.png); }
            .nerfing::before { content: url(StS/intent-nerf.png); }
            .meganerf::before { content: url(StS/intent-meganerf.png); }
            .unknown::before { content: url(StS/intent-unknown.png); }
            .attack-block::before { content: url(StS/intent-attackblock.png); }
            .block-buff::before { content: url(StS/intent-blockbuff.png); }
            .attack-nerf::before { content: url(StS/intent-attacknerf.png); }
            .attack-buff::before { content: url(StS/intent-attackbuff.png); }
            .block-nerf::before { content: url(StS/intent-blocknerf.png); }
            #combatLog {
                overflow: scroll;
                width: 600px;
                height: 400px;
            }
            #cardModal, #bossModal, #selectionModal {
                position: fixed;
                z-index: 1;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0,0,0,0.7);
            }
            #cardModalContent, #bossModalContent, #selectionModalContent {
                background-color: #555;
                margin: 15% auto;
                padding: 20px;
                width: 80%;
            }
        </style>
    </head>
    <body>
        <div id="selectionModal" style="display: none;">
            <div id="selectionModalContent"></div>
        </div>
        <div id="cardModal" style="display: none;">
            <div id="cardModalContent">
                <p>Choose a card to add to your deck:</p>
                <button id="modalCard1" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(0);"></button>
                <button id="modalCard2" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(1);"></button>
                <button id="modalCard3" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(2);"></button>
                <button id="modalSkipCard" class="Skill" onclick="getId('cardModal').style.display = 'none'; finishAddCard(-1);">Skip</button>
            </div>
        </div>
        <div id="bossModal" style="display: none;">
            <div id="bossModalContent">
                <p>Choose a Rare Relic to obtain:</p>
                <button id="modalRelic1" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(0);"></button>
                <button id="modalRelic2" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(1);"></button>
                <button id="modalRelic3" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(2);"></button>
            </div>
        </div>
        <span id="statusLineB4"></span>
        <button onclick="alert(deck.map(x=>x.name).join(', '));">View Deck | <span style="color:white" id="deckSize">10</span></button>
        <span id="statusLine"></span>
        <br /><br />
        <table id="gameScreen">
            <tr>
                <td id="playerTd">
                    <div id="player"></div>
                    <br />
                    <span id="energy" class="tt"></span>&nbsp;&nbsp;&nbsp;<span id="hand"></span>
                    <br /><br />
                    <button id="discardPile" onclick="alert(discardPile.map(x => x.name).join(', '))">View Discard Pile</button>
                    <button id="drawPile" onclick="alert(shuffle(drawPile.map(x => x.name).join(', ')))">View Draw Pile</button>
                    <button id="exhaustPile" onclick="alert(exhaustPile.map(x => x.name).join(', '))">View Exhaust Pile</button>
                    | <button onclick="endTurn()">End Turn</button>
                </td>
                <td id="enemiesTd">
                    <div id="enemies"></div>
                </td>
            </tr>
            <tr>
                <td>
                    <br /><br /><br />
                    <h3>Combat log</h3>
                    <pre id="combatLog"></pre>
                </td>
                <td></td>
            </tr>
        </table>
        <div id="rewardsScreen" style="display: none;">
            You won! Rewards:<br />
            <button id="goldReward"></button>
            <button id="cardReward" onclick="getId('cardReward').style.display = 'none'; addCard('random');">Add a card to your deck</button>
            <button id="potionReward"></button>
            <button id="relicReward" class="tt"></button>
            <button id="bossRelicReward" class="tt"></button>
            <button id="closeRewards" onclick="showMap();">Continue</button>
        </div>
        <table id="mapScreen" style="display: none;"></table>
        <div id="restScreen" style="display: none;">
            <span>You are at a Rest Site. Choose an option below.</span>
            <br />
            <button onclick="hp = Math.min(maxHp, Math.round(hp+0.3*maxHp)); showMap();" class="tt">Rest<span class="txt">Heal 30% of your Max HP.</span></button>
            <button onclick="upgradeDialog();" class="tt">Smith<span class="txt">Upgrade a card in your deck.</span></button>
            <div id="upgradeDialog" style="display: none;">
                <p id="cardDesc"></p>
                <button onclick="upgradeCard(cardToUpgrade); getId('upgradeDialog').style.display = 'none'; showMap();">Confirm</button>
            </div>
        </div>
        <table id="merchantScreen" style="display: none;">
        </table>
        <script>
            alert("Welcome to COSTS (Clone Of Slay The Spire)!");
            let startTime = Date.now();
            function shuffle(array) {
                let currentIndex = array.length, randomIndex;
                while(currentIndex != 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            }
            let getId = x => document.getElementById(x);
            let choice = x => x[Math.floor(Math.random()*x.length)];
            let resolvePromise;
            async function showCardChoiceModal(displayCards, prompt) {
                getId("selectionModalContent").innerHTML = prompt + "<br/>";
                for(let c of displayCards) {
                    let cardButton = document.createElement("button");
                    cardButton.setAttribute("onclick", "resolvePromise('"+c.name+"');");
                    cardButton.setAttribute("class", "tt");
                    cardButton.innerHTML = c.name+"<span class='txt'>"+addCircle(c.cost.toString())+" "+c.type+"<br/>"+unformat(c.desc)+"</span>";
                    getId("selectionModalContent").appendChild(cardButton);
                }
                getId("selectionModal").style.display = "block";
                let promise = new Promise((resolve, reject) => {
                    resolvePromise = resolve;
                });
                let chosenCard;
                await promise.then((result) => {
                    getId("selectionModal").style.display = "none";
                    chosenCard = displayCards[displayCards.map(x=>x.name).indexOf(result)];
                });
                return chosenCard;
            }
            async function choose(c, p) {
                if(c.length >= 1) {
                    let wooga = await showCardChoiceModal(c, p);
                    return wooga;
                } else {
                    return null;
                }
            }
            let mousex = 0;
            let mousey = 0;
            document.onmousemove = function(e) {
                let x = document.getElementsByClassName("txt");
                mousex = e.clientX;
                mousey = e.clientY;
                for (t of x) {
                    t.style.left = (mousex+10) + "px";
                    t.style.top = (mousey+10+window.pageYOffset) + "px";
                }
            }
            function unformat(desc) {
                return desc.replace(" (Costs [BLOOD4BLOOD] energy)", "").replace("[HEAVYBLADE]", 14).replace("[HEAVYBLADE+]", 14).replace("[RAMPAGE]", 8).replace(" ([BLOCK] damage)", "").replace("[DAM", "").replace("[BLK", "").replace("]", "")
            }
            function log(message, color="white") {
                getId('combatLog').innerHTML += "<span style='color: "+color+"'>" + message + "</span>\n";
            }
            function addCircle(char) {
                let circles = {"X": "ⓧ", "0": "⓪", "1": "①", "2": "②", "3": "③", "4": "④", "5": "⑤"};
                return "<b>"+circles[char]+"</b>";
                //return circles[char];
            }
            class Card {
                /*
                'effect' is a function that takes the current target, whether it is used or not.
                */
                constructor(name, cost, type, desc, use, flags=[]) {
                    this.name = name;
                    this.cost = cost;
                    this.type = type;
                    this.desc = desc;
                    this.use = use;
                    this.flags = flags;
                    this.number = Math.random();
                }
                async play() {
                    let played = false;
                    if(this.cost == "X") {
                        for(let x=0; x<energy; x++) {
                            this.use(target);
                        }
                        energy = 0;
                        played = true;
                    } else {
                        let newCost = this.cost;
                        if(this.flags.includes("blood4blood")) {
                            newCost = Math.max(0, stats.timesLostHp);
                        }
                        if(energy >= newCost && !(this.flags.includes("unplayable"))) {
                            energy -= newCost;
                            if(!this.use) {alert("Uh oh! Seems like card [" + (this.name ? this.name : "unnamed") + "] has no `use` function");}
                            Promise.resolve(this.use(target));
                            played = true;
                        }
                    }
                    if(played) {
                        hand.splice(hand.indexOf(this), 1);
                        if(this.flags.includes("exhausted")) {
                            exhaustPile.push(this);
                            drawCard(hasBuff("Dark Embrace"));
                            if(hasBuff("Feel No Pain") > 0) {gainBuff("Block", hasBuff("Feel No Pain"));}
                            for(let r of relics) {if(r.trigger == "on_exhaust") {r.effect();}}
                        } else {
                            discardPile.push(this);
                        }
                        await this.play_success();
                    }
                    updateHtml();
                }
                async play_success() {
                    if(this.type == "Skill") {
                        stats.skillsThisTurn += 1;
                        for(let e of enemies) {
                            if(e.hasBuff("Enrage") > 0) {e.gainBuff("Strength", e.hasBuff("Enrage"));}
                        }
                        for(let r of relics) {
                            if(r.trigger == "on_skill") {r.effect();}
                            if(r.trigger == "3_skills" && stats.skillsThisTurn % 3 == 0) {r.effect();}
                        }
                    }
                    if(this.type == "Skill") {
                        for(let r of relics) {if(r.trigger == "on_power") {r.effect();}}
                    }
                    if(this.type == "Attack") {
                        stats.attacksThisTurn += 1;
                        if(hasBuff("Rage") > 0) {gainBuff("Block", hasBuff("Rage"));}
                        if(hasBuff("Double Tap") > 0) {
                            loseBuff("Double Tap", 1);
                            hand.push(this);
                            discardPile.splice(discardPile.indexOf(this), 1);
                            if(this.cost != "X") {energy += this.cost;}
                            await this.play();
                        }
                        for(let r of relics) {
                            if(r.trigger == "on_attack") {r.effect();}
                            if(r.trigger == "3_attacks" && stats.attacksThisTurn % 3 == 0) {r.effect();}
                        }
                    }
                    if(this.name.toLowerCase().includes("strike")) {
                        for(let r of relics) {if(r.trigger == "strike") {r.effect();}}
                    }
                    if(this.type != "Attack") {
                        if(hasBuff("Hex") > 0) {
                            for(let i=0; i<hasBuff("Hex"); i++) {discardPile.push(statusCards["Dazed"]());}
                        }
                    }
                }
            }
            
            class Enemy {
                /*
                'attacks' is a list of objects. Each one has a 'desc' and an 'effect'.
                The effect is a function that takes this object as a parameter (because it cannot use 'this').
                */
                constructor(name, hp, attacks, flags=[]) {
                    this.name = name;
                    this.number = Math.random();
                    this.hp = hp;
                    this.maxHp = hp;
                    this.attacks = attacks;
                    this.flags = flags;
                    this.buffs = [];
                    this.intent = (this.flags.includes("randomize") ? choice(attacks) : attacks[0]);
                }
                attack() {
                    this.intent.effect(this);
                    if(this.flags.includes("randomize")) {
                        // We need to change attacks each time.
                        let newIntent = choice(this.attacks);
                        while(newIntent == this.intent) {
                            newIntent = choice(this.attacks);
                        }
                        this.intent = newIntent;
                    } else if(this.attacks.indexOf(this.intent) + 1 == this.attacks.length && !(this.flags.includes("no-repeat"))) {
                        // Repeat is allowed and we are at the end: restart.
                        this.intent = this.attacks[0];
                    } else if(this.attacks.indexOf(this.intent) + 1 != this.attacks.length) {
                        // Else if we have something to go to: go to it.
                        this.intent = this.attacks[this.attacks.indexOf(this.intent) + 1];
                    }
                }
                hasBuff(name) {
                    for(let b of this.buffs) {
                        if(b.name == name) {
                            return b.amt;
                        }
                    }
                    return 0;
                }
                gainBuff(name, amt) {
                    if(debuffs.includes[name] && this.hasBuff("Artifact") > 0) {this.loseBuff("Artifact", 1); return;}
                    let newAmt = amt;
                    if(this.hasBuff("Frail") > 0 && name == "Block") {newAmt = Math.round(newAmt * 0.75);}
                    if(this.hasBuff("Dexterity") > 0 && name == "Block") {newAmt -= this.hasBuff("Dexterity");}
                    if(this.hasBuff("Minus Dexterity") > 0 && name == "Block") {newAmt -= this.hasBuff("Minus Dexterity");}
                    for(let b of this.buffs) {
                        if(b.name == name) {
                            b.amt += newAmt;
                            return;
                        }
                    }
                    this.buffs.push({name: name, amt: newAmt});
                    if(name=="Vulnerable") {
                        for(let r of relics) {if(r.trigger == "apply_vulnerable") {r.effect();}}
                    }
                    if(amt > 0) {log(this.name+" gained "+amt+" "+name);}
                }
                loseBuff(name, amt=9999) {
                    for(let b of this.buffs) {
                        if(b.name == name) {
                            let prevAmt = b.amt;
                            if(amt >= b.amt) {
                                this.buffs.splice(this.buffs.indexOf(b), 1);
                            } else {
                                b.amt -= amt;
                            }
                            if(amt > 0) {log(this.name+" lost "+Math.min(amt, prevAmt)+" "+name);}
                            return;
                        }
                    }
                }
                dealDamage(amt) {
                    let finalAmt = amt;
                    if(hasBuff("Vulnerable") > 0) {finalAmt = Math.round(finalAmt * 1.5);}
                    if(this.hasBuff("Weak") > 0) {finalAmt = Math.round(finalAmt * 0.75);}
                    finalAmt += this.hasBuff("Strength");
                    if(hasBuff("Buffer") > 0 && finalAmt > hasBuff("Block")) {finalAmt = 0; loseBuff("Buffer", 1);}
                    
                    if(finalAmt > 0){log(this.name+" dealt "+Math.max(0, finalAmt-hasBuff("Block"))+" damage"+(
                        hasBuff("Block")>0 ? " (+ "+Math.min(hasBuff("Block"), finalAmt)+" blocked)" : ""
                    ));}
                    
                    hp -= Math.max(0, finalAmt - hasBuff("Block"));
                    if(finalAmt - hasBuff("Block") > 0) {
                        stats.timesLostHp++;
                        if(hasBuff("Thorns") > 0) {dealDamage(this, hasBuff("Thorns")); updateHtml();}
                        for(let r of relics) {if(r.trigger == "lose_hp") {r.effect();}}
                        getId("html").style.background = "#600";
                        let normalColor1 = function(){getId("html").style.background = "#511";}
                        let normalColor2 = function(){getId("html").style.background = "#411";}
                        let normalColor3 = function(){getId("html").style.background = "#322";}
                        let normalColor4 = function(){getId("html").style.background = "#222";}
                        setTimeout(normalColor1, 40);
                        setTimeout(normalColor2, 80);
                        setTimeout(normalColor3, 120);
                        setTimeout(normalColor4, 160);
                    }
                    loseBuff("Block", finalAmt);
                }
            }
            
            class Relic {
                constructor(name, desc, trigger, effect) {
                    this.name = name;
                    this.desc = desc;
                    this.trigger = trigger;
                    this.use = effect;
                }
                effect() {
                    this.use();
                }
            }
            
            function hasBuff(name) {
                for(let b of buffs) {
                    if(b.name == name) {
                        return b.amt;
                    }
                }
                return 0;
            }
            function gainBuff(name, amt) {
                if(debuffs.includes[name] && hasBuff("Artifact") > 0) {loseBuff("Artifact", 1); return;}
                let newAmt = amt;
                if(hasBuff("Frail") > 0 && name == "Block") {newAmt = Math.round(newAmt * 0.75);}
                if(hasBuff("Dexterity") > 0 && name == "Block") {newAmt -= hasBuff("Dexterity");}
                if(hasBuff("Minus Dexterity") > 0 && name == "Block") {newAmt -= hasBuff("Minus Dexterity");}
                if(hasBuff("Juggernaut") > 0 && name == "Block") {dealDamage(choice(enemies), hasBuff("Juggernaut"));}
                for(let b of buffs) {
                    if(b.name == name) {
                        b.amt += newAmt;
                        return;
                    }
                }
                buffs.push({name: name, amt: newAmt});
                if(amt > 0) {log("You gained "+amt+" "+name);}
            }
            function loseBuff(name, amt=9999) {
                for(let b of buffs) {
                    if(b.name == name) {
                        let prevAmt = b.amt;
                        if(amt >= b.amt) {
                            buffs.splice(buffs.indexOf(b), 1);
                        } else {
                            b.amt -= amt;
                        }
                        if(amt > 0) {log("You lost "+Math.min(amt, prevAmt)+" "+name);}
                        return;
                    }
                }
            }
            function dealDamage(actor, amt, shiv=true) {
                let finalAmt = amt;
                if(actor.hasBuff("Vulnerable")) { finalAmt = Math.round(finalAmt * 1.5); }
                if(hasBuff("Weak")) { finalAmt = Math.round(finalAmt * 0.75); }
                finalAmt += hasBuff("Strength");
                finalAmt -= hasBuff("Minus Strength");
                
                if(finalAmt > 0) {log("You dealt "+Math.max(0, finalAmt-actor.hasBuff("Block"))+" damage"+(
                    actor.hasBuff("Block")>0 ? " (+ "+Math.min(actor.hasBuff("Block"), finalAmt)+" blocked)" : ""
                )+" to "+actor.name);}
                else {
                    log("Not dealing any damage.");
                }
                
                actor.hp -= Math.max(0, finalAmt - actor.hasBuff("Block"));
                if(finalAmt - actor.hasBuff("Block") > 0) {
                    if(stats.hasAttacked == false) {
                        stats.hasAttacked = true;
                        for(let r of relics) {if(r.trigger == "first_attack") {r.effect();}}
                        if(hasBuff("Vigor") > 0) {
                            loseBuff("Strength", hasBuff("Vigor"));
                            loseBuff("Vigor");
                        }
                    }
                }
                actor.loseBuff("Block", finalAmt);
                if(finalAmt > 0 && actor.hasBuff("Thorns") > 0) {actor.dealDamage(actor.hasBuff("Thorns")); updateHtml();}
            }
            let buffDesc = {
                "Block": "Until next turn, prevents [AMT] damage.",
                "Vulnerable": "Take 50% more damage for [AMT] turn[s].",
                "Weak": "Deal 25% less damage for [AMT] turn[s].",
                "Strength": "Attacks deal [AMT] more damage.",
                "Dexterity": "Cards gain you [AMT] more Block.",
                "Strength Down": "At the end of this turn, lose [AMT] Strength.",
                "No Draw": "Cannot draw cards for [AMT] turn[s].",
                "Combust": "At the end of your turn, lose 1 HP and deal [AMT] damage to ALL enemies.",
                "Dark Embrace": "When a card is Exhausted, draw [AMT] card[s].",
                "Thorns": "When recieving unblocked damage, deal [AMT] damage back.",
                "Ritual": "At end of turn, gain [AMT] Strength.",
                "Frail": "Gain 25% less Block for [AMT] turn[s].",
                "Enrage": "When you play a Skill, gains [AMT] Strength.",
                "Minus Strength": "Attacks deal [AMT] less damage.",
                "Minus Dexterity": "Gain [AMT] less block from cards.",
                "Evolve": "Whenever you draw a Status card, draw [AMT] card[s].",
                "Pen Nib": "When you get 10 Pen Nib, deal 10 damage.",
                "Feel No Pain": "When a card is Exausted, gain [AMT] Block.",
                "Fire Breathing": "Whenever you draw a Status card, deal [AMT] damage to ALL enemies.",
                "Metallicize": "Start each turn with [AMT] Block.",
                "Rage": "For each Attack you play this turn, gain [AMT] Block.",
                "Rampage": "Increase Rampage's damage by [AMT].",
                "Barricade": "Block is not removed at the start of your turn.",
                "Energize": "Gain [AMT] more energy each turn.",
                "Brutality": "At the start of your turn, lose 1 HP and draw [AMT] card[s].",
                "Double Tap": "The next Attack you play is played [AMT] more time[s]",
                "Juggernaut": "Whenever you gain Block, deal [AMT] damage to a random enemy.",
                "Regen": "At end of turn, heal [AMT] HP and reduce Regen by 1.",
                "Dexterity Down": "At end of turn, lose [AMT] Dexterity.",
                "Artifact": "Negates the next [AMT] debuff[s].",
                "Hex": "When you play a non-Attack card, add [AMT] Dazed to your discard pile.",
                "Draw Reduction": "Draw 1 fewer card for [AMT] turn[s].",
                "Buffer": "Prevent the first [AMT] unblocked hit[s].",
                "Next Turn Block": "Gain [AMT] Block next turn.",
                "Vigor": "[AMT] of your strength only applies to 1st attack.",
                "Next Turn Energy": "Gain [AMT] more energy next turn.",
                "Poison": "Lose [AMT] HP at end of turn. Poison goes down each turn.",
                "Accuracy": "Shivs deal [AMT] more damage.",
                "Blur": "Keep your Block for [AMT] turn[s]."
            };
            let debuffs = ["Vulnerable", "Weak", "Strength Down", "No Draw", "Frail", "Minus Strength", "Minus Dexterity", "Dexterity Down", "Hex", "Draw Reduction", "Poison"];
            let statusCards = {
                "Wound": () => new Card("Wound", 0, "Status", "Unplayable.", function(enemy){}, ["unplayable"]),
                "Dazed": () => new Card("Dazed", 0, "Status", "Unplayable. Ethereal.", function(enemy){}, ["unplayable", "ethereal"]),
                "Slimed": () => new Card("Slimed", 1, "Status", "Exhaust.", function(enemy){}, ["exhausted"]),
                "Burn": () => new Card("Burn", 0, "Status", "Unplayable. Lose 1 HP at end of turn.", function(enemy){}, ["unplayable", "burning"])
            };
            
            function showMap() {
                if(mapY >= 15) {
                    mapY = 0;
                    hp = maxHp;
                    mapGen();
                    maxEnergy += 1;
                    if(actNum == 1) {
                        actNum = 2;
                        alert("Congratulations! You completed Act I! That's 1/3 of the game!");
                    } else if(actNum == 2) {
                        actNum = 3;
                        alert("Congratulations! You completed Act II! That's 2/3 of the game!");
                    } else if(actNum == 3) {
                        actNum = 999;
                        alert("Congratulations! You completed Act III! You Win!");
                    }
                }
                updateStatLine();
                getId("rewardsScreen").style.display = "none";
                getId("restScreen").style.display = "none";
                getId("merchantScreen").style.display = "none";
                if(actNum > 3) {return;}
                getId("mapScreen").style.display = "block";
                getId("mapScreen").innerHTML = "Select your next room...";
                for(let floor in map) {
                    let floorElem = document.createElement("tr");
                    for(let node in map[floor]) {
                        let nodeElem = document.createElement("td");
                        if(map[floor][node] != "") {
                            let nodeButton = document.createElement("button");
                            nodeButton.innerHTML = map[floor][node]+"<span class='txt'>"+
                                (map[floor][node]=="enemy" ? "Fight some monsters. Gain gold and add a card if you win." : 
                                  (map[floor][node]=="elite" ? "Fight a strong monster. Gain gold, add a card, and get a relic if you win." : 
                                    (map[floor][node]=="rest&nbsp;" ? "Rest and heal some HP." : 
                                     (map[floor][node]=="shop&nbsp;" ? "Buy cards and relics at the shop.<br/>Costs around $60 for a card, $200 for a relic." : "Fight a Boss. Cool stuff if you win.")))
                                )+"</span>";
                            nodeButton.setAttribute("class", "tt notbig");
                            if(floor-1 == mapY && Math.abs(node-mapX) <= 1) {
                                nodeButton.setAttribute("onclick", `gotoMap(${floor}, ${node});`);
                            } else if(floor == mapY && node == mapX) {
                                nodeButton.innerHTML = "(You)";
                            } else {
                                nodeButton.setAttribute("class", "nonbutton notbig");
                            }
                            nodeElem.appendChild(nodeButton);
                        }
                        floorElem.appendChild(nodeElem);
                    }
                    getId("mapScreen").appendChild(floorElem);
                }
            }
            function gotoMap(y, x) {
                mapY = y;
                mapX = x;
                let readyBattle = function() {
                    getId("mapScreen").style.display = "none";
                    getId("gameScreen").style.display = "block";
                    drawPile = shuffle(deck.slice(0)); // no shallow copy
                    discardPile = [];
                    exhaustPile = [];
                    hand = [];
                    buffs = [];
                    stats = {timesLostHp: 0, hasAttacked: false, attacksThisTurn: 999, skillsThisTurn: 999, rested: stats.rested};
                    target = enemies[0];
                    for(let r of relics) {if(r.trigger == "combat_start") {r.effect();}}
                    for(let card of drawPile) {
                        if(card.flags.includes("innate")) {
                            drawPile.splice(drawPile.indexOf(card), 1);
                            hand.push(card);
                        }
                    }
                    getId("combatLog").innerHTML = "";
                    startTurn();
                }
                if(map[y][x] == "enemy") {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleEnemies.slice(0))();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleEnemies_act2.slice(0))();
                    } else {
                        nme = () => choice(possibleEnemies_act3.slice(0))();
                    }
                    if(mapY >= 2) {enemies = [nme(), nme()]}
                    else {enemies = [nme()]}
                    eliteBattle = false;
                    bossBattle = false;
                    readyBattle();
                } else if(map[y][x] == "elite") {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleElites.slice(0))();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleElites_act2.slice(0))();
                    } else {
                        nme = () => choice(possibleElites_act3.slice(0))();
                    }
                    enemies = [nme()];
                    eliteBattle = true;
                    bossBattle = false;
                    readyBattle();
                } else if(map[y][x].includes("BOSS")) {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleBosses.slice(0))();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleBosses_act2.slice(0))();
                    } else {
                        nme = () => choice(possibleBosses_act3.slice(0))();
                    }
                    enemies = [nme()];
                    eliteBattle = false;
                    bossBattle = true;
                    readyBattle();
                } else if(map[y][x] == "rest&nbsp;") {
                    getId("mapScreen").style.display = "none";
                    getId("restScreen").style.display = "block";
                } else if(map[y][x] == "shop&nbsp;") {
                    getId("mapScreen").style.display = "none";
                    getId("merchantScreen").style.display = "block";
                    getId("merchantScreen").innerHTML = "";
                    offers = [];
                    for(let i=0; i<6; i++) {
                        let offer = randCard()();
                        let cardCost = Math.round(Math.random()*37 + 45); // cost: 45g to 82g
                        offers.push({offer: i, cost: cardCost});
                        if(i==0) {cardCost = Math.round(cardCost * 0.45);}
                        if(i==5) {cardCost = Math.round(Math.random()*30 + 135); offer = randRareCard()();} // 6th card is rare
                        let cardElem = document.createElement("tr");
                        let nameWrapper = document.createElement("td");
                        let nameElem = document.createElement("button");
                        let costElem = document.createElement("td");
                        cardElem.setAttribute("id", `cardElem_${i}`);
                        nameElem.setAttribute("id", `cardName_${i}`);
                        nameElem.innerHTML = offer.name+"<span class='txt'>"+addCircle(offer.cost.toString())+" "+offer.type+"<br/>"+unformat(offer.desc)+"</span>";
                        if(gold >= cardCost) {
                            if(i==0) {
                                nameElem.setAttribute("class", "Skill tt");
                            } else if(i==5) {
                                nameElem.setAttribute("class", "Power tt");
                            } else {
                                nameElem.setAttribute("class", "tt");
                            }
                        } else {
                            nameElem.setAttribute("class", "tt unplayable");
                        }
                        nameElem.setAttribute("onclick", `if(gold >= ${cardCost}) {
gold -= ${cardCost};
deck.push(new Card("${offer.name}", ${offer.cost}, "${offer.type}", "${offer.desc}", ${offer.use}, ${JSON.stringify(offer.flags)}));
getId("cardElem_${i}").style.display = "none";
updateStatLine();
updateShopScreen();
}
                        `);
                        costElem.innerHTML = "Cost: $"+cardCost;
                        
                        nameWrapper.appendChild(nameElem);
                        cardElem.appendChild(nameWrapper);
                        cardElem.appendChild(costElem);
                        getId("merchantScreen").appendChild(cardElem);
                    }
                    for(let i=0; i<3; i++) {
                        let offer = choice(relicPool)();
                        let relicCost = Math.round(Math.random()*119 + 143);
                        offers.push({offer: i+100, cost: relicCost});
                        let relicElem = document.createElement("tr");
                        let nameWrapper = document.createElement("td");
                        let nameElem = document.createElement("button");
                        let costElem = document.createElement("td");
                        relicElem.setAttribute("id", `relicElem_${i}`);
                        nameElem.setAttribute("id", `relicName_${i}`);
                        nameElem.innerHTML = offer.name+"<span class='txt'>"+offer.desc+"</span>";
                        if(gold >= relicCost) {
                            nameElem.setAttribute("class", "Status tt");
                        } else {
                            nameElem.setAttribute("class", "Status tt unplayable");
                        }
                        nameElem.setAttribute("onclick", `if(gold >= ${relicCost}) {
gold -= ${relicCost};
let r = new Relic("${offer.name}", "${offer.desc}", "${offer.trigger}", ${offer.use});
relics.push(r);
if(r.trigger=='on_pickup') {r.effect();}
getId("relicElem_${i}").style.display = "none";
updateStatLine();
updateShopScreen();
}
                        `);
                        costElem.innerHTML = "Cost: $"+relicCost;
                        
                        nameWrapper.appendChild(nameElem);
                        relicElem.appendChild(nameWrapper);
                        relicElem.appendChild(costElem);
                        getId("merchantScreen").appendChild(relicElem);
                    }
                    let continueElem = document.createElement("tr");
                    let continueWrapper = document.createElement("td");
                    let continueBtn = document.createElement("button");
                    continueBtn.innerHTML = "Continue";
                    continueBtn.setAttribute("onclick", "showMap();");
                    continueWrapper.appendChild(continueBtn);
                    continueElem.appendChild(continueWrapper);
                    getId("merchantScreen").appendChild(continueElem);
                }
            }
            function updateShopScreen() {
                for(let i of offers) {
                    if(i.offer >= 100) {
                        let relicElem = getId("relicName_"+(i.offer-100));
                        if(gold >= i.cost) {
                            relicElem.setAttribute("class", "Status tt");
                        } else {
                            relicElem.setAttribute("class", "unplayable tt");
                        }
                    } else {
                        let cardElem = getId("cardName_"+i.offer);
                        if(gold < i.cost) {
                            cardElem.setAttribute("class", "unplayable tt");
                        } else if(i.offer==0) {
                            cardElem.setAttribute("class", "Skill tt");
                        } else {
                            cardElem.setAttribute("class", "tt");
                        }
                    }
                }
            }
            
            //
            // Basics
            //
            let strike = () => new Card("Strike", 1, "Attack", "Deal [DAM6] damage.", function(enemy){
                dealDamage(enemy, 6);
            });
            let defend = () => new Card("Defend", 1, "Skill", "Gain [BLK5] Block.", function(enemy){
                gainBuff("Block", 5);
            });
            let bash = () => new Card("Bash", 2, "Attack", "Deal [DAM8] damage, apply 2 Vulnerable.", function(enemy){
                dealDamage(enemy, 8); enemy.gainBuff("Vulnerable", 2);
            });
            
            //
            // Commons
            //
            let bodySlam = () => new Card("Body Slam", 1, "Attack", "Deal damage equal to your Block. ([BLOCK] damage)", function(enemy){
                dealDamage(enemy, hasBuff("Block"));
            });
            let clash = () => new Card("Clash", 0, "Attack","Deal [DAM14] damage if all cards in your hand are Attacks.", function(enemy){
                if(!hand.map(x=>x.type=="Attack").includes(false)) {dealDamage(enemy, 14);} else {alert("Failed to play Clash: There are non-Attack cards in your hand.");}
            });
            let cleave = () => new Card("Cleave", 1, "Attack", "Deal [DAM8] damage to ALL enemies.", function(enemy){
                for(let e of enemies){dealDamage(e, 8);}
            });
            let clothesline = () => new Card("Clothesline", 2, "Attack", "Deal [DAM12] damage, apply 2 Weak.", function(enemy){
                dealDamage(enemy, 12); enemy.gainBuff("Weak", 2);
            });
            let flex = () => new Card("Flex", 0, "Skill", "Gain 2 Strength. At the end of your turn, lose 2 Strength.", function(enemy){
                gainBuff("Strength", 2); gainBuff("Strength Down", 2);
            });
            let headbutt = () => new Card("Headbutt", 1, "Attack", "Deal [DAM9] damage. Put a card from your discard pile on top of your draw pile.", async function(enemy){
                dealDamage(enemy, 9);
                let chosen = await choose(discardPile, "Choose a card to put on top of your Draw Pile.");
                if(chosen) {
                    drawPile = [chosen, ...drawPile];
                    discardPile.splice(discardPile.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let heavyBlade = () => new Card("Heavy Blade", 2, "Attack", "Deal [HEAVYBLADE] damage. Strength affects the damage 3 times.", function(enemy){
                dealDamage(enemy, 14 + 2 * hasBuff("Strength"));
            });
            let ironWave = () => new Card("Iron Wave", 1, "Attack", "Gain [BLK5] Block. Deal [DAM5] damage.", function(enemy){
                dealDamage(enemy, 5); gainBuff("Block", 5);
            });
            let pommelStrike = () => new Card("Pommel Strike", 1, "Attack", "Deal [DAM9] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 9); drawCard();
            });
            let shrugItOff = () => new Card("Shrug it Off", 1, "Skill", "Gain [BLK8] Block. Draw a card.", function(enemy){
                gainBuff("Block", 8); drawCard();
            });
            let swordBoomerang = () => new Card("Sword Boomerang", 1, "Attack", "Deal [DAM3] damage to a random enemy 3 times.", function(enemy){
                dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3);
            });
            let thunderclap = () => new Card("Thunderclap", 1, "Attack", "Deal [DAM4] damage and apply 1 Vulnerable to ALL enemies.", function(enemy){
                for(let e of enemies){dealDamage(e, 4); e.gainBuff("Vulnerable", 1);}
            });
            let trueGrit = () => new Card("True Grit", 1, "Skill", "Gain [BLK7] Block. Exhaust a random card in your hand.", function(enemy){
                gainBuff("Block", 7); let c=choice(hand); hand.splice(hand.indexOf(c), 1); exhaustPile.push(c);
            });
            let twinStrike = () => new Card("Twin Strike", 1, "Attack", "Deal [DAM5] damage twice.", function(enemy){
                dealDamage(enemy, 5); dealDamage(enemy, 5);
            });
            let wildStrike = () => new Card("Wild Strike", 1, "Attack", "Deal [DAM12] damage. Shuffle a Wound into your discard pile.", function(enemy){
                dealDamage(enemy, 12); discardPile.push(statusCards["Wound"]());
            });
            
            //
            // Uncommons
            //
            let battleTrance = () => new Card("Battle Trance", 0, "Skill", "Draw 3 cards. You cannot draw additional cards this turn.", function(enemy){
                drawCard(3); gainBuff("No Draw", 1);
            });
            let bloodForBlood = () => new Card("Blood for Blood", 4, "Attack", "Deal [DAM18] damage. -1 cost each time you lose HP. (Costs [BLOOD4BLOOD] energy)", function(enemy){
                dealDamage(enemy, 18);
            }, ["blood4blood"]);
            let bloodletting = () => new Card("Bloodletting", 0, "Skill", "Lose 3 HP. Gain 2 energy.", function(enemy){
                hp -= 3; energy += 2;
            });
            let burningPact = () => new Card("Burning Pact", 1, "Skill", "Exhaust 1 card. Draw 2 cards.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name != "Burning Pact"), "Choose a card to Exhaust.");
                if(chosen) {
                    hand.splice(hand.indexOf(chosen), 1);
                    exhaustPile.push(chosen);
                    drawCard(2);
                } else {
                    alert("Failed to play Burning Pact: No remaining cards in hand.");
                }
                updateHtml();
            });
            let carnage = () => new Card("Carnage", 2, "Attack", "Ethereal. Deal [DAM20] damage.", function(enemy){
                dealDamage(enemy, 20);
            }, ["ethereal"]);
            let combust = () => new Card("Combust", 1, "Power", "At the end of your turn, lose 1 HP and deal 5 damage to ALL enemies.", function(enemy){
                gainBuff("Combust", 5);
            }, ["exhausted"]);
            let darkEmbrace = () => new Card("Dark Embrace", 2, "Power", "Whenever a card is Exhausted, draw a card.", function(enemy){
                gainBuff("Dark Embrace", 1);
            }, ["exhausted"]);
            let disarm = () => new Card("Disarm", 1, "Skill", "Enemy gets -2 Strength. Exhaust.", function(enemy){
                enemy.gainBuff("Minus Strength", 2);
            }, ["exhausted"]);
            let dropkick = () => new Card("Dropkick", 1, "Attack", "Deal [DAM5] damage. If the enemy has Vulnerable, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 5);
                if(enemy.hasBuff("Vulnerable") > 0) {
                    energy++;
                    drawCard();
                }
            });
            let dualWield = () => new Card("Dual Wield", 1, "Skill", "Copy an Attack or Power card in your hand.", async function(enemy){
                let chosen = await choose(hand.filter(x=>["Attack","Power"].includes(x.type)), "Choose a card to copy.");
                if(chosen) {
                    hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use));
                    updateHtml();
                } else {
                    alert("Failed to play Dual Wield: No Attack or Power cards in hand.");
                }
            });
            let entrench = () => new Card("Entrench", 2, "Skill", "Double your Block.", function(enemy){
                if(hasBuff("Block")>0) {gainBuff("Block", hasBuff("Block"));}
            });
            let evolve = () => new Card("Evolve", 1, "Power", "Whenever you draw a Status card, draw another card.", function(enemy){
                gainBuff("Evolve", 1);
            }, ["exhausted"]);
            let feelNoPain = () => new Card("Feel No Pain", 1, "Power", "When a card is Exhausted, gain [BLK3] Block.", function(enemy){
                gainBuff("Feel No Pain", 3);
            }, ["exhausted"]);
            let fireBreathing = () => new Card("Fire Breathing", 1, "Power", "Whenever you draw a Status card, deal 6 damage to ALL enemies", function(enemy){
                gainBuff("Fire Breathing", 6);
            }, ["exhausted"]);
            let flameBarrier = () => new Card("Flame Barrier", 2, "Skill", "Gain [BLK12] Block and 2 Thorns.", function(enemy){
                gainBuff("Block", 12); gainBuff("Thorns", 2);
            });
            let ghostlyArmor = () => new Card("Ghostly Armor", 1, "Skill", "Ethereal. Gain [BLK10] Block.", function(enemy){
                gainBuff("Block", 10);
            }, ["ethereal"]);
            let hemokinesis = () => new Card("Hemokinesis", 1, "Attack", "Lose 2 HP. Deal [DAM15] damage.", function(enemy){
                hp -= 2; dealDamage(enemy, 15);
            });
            let infernalBlade = () => new Card("Infernal Blade", 0, "Skill", "Add a random Attack to your hand. Exhaust.", function(enemy){
                let extraCard = randCard()(); // looks weird ik
                while(extraCard.type != "Attack") {extraCard = randCard()();}
                hand.push(extraCard);
            }, ["exhausted"]);
            let inflame = () => new Card("Enflame", 1, "Power", "Gain 2 Strength.", function(enemy){
                gainBuff("Strength", 2);
            }, ["exhausted"]);
            let intimidate = () => new Card("Intimidate", 0, "Skill", "Apply 1 Weak to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {e.gainBuff("Weak", 1);}
            }, ["exhausted"]);
            let metallicize = () => new Card("Metallicize", 1, "Power", "Start each turn with [BLK3] Block.", function(enemy){
                gainBuff("Metallicize", 3);
            }, ["exhausted"]);
            let powerThrough = () => new Card("Power Through",1,"Skill","Add 2 Wounds to your hand. Gain [BLK15] Block.",function(enemy){
                hand.push(statusCards["Wound"]()); hand.push(statusCards["Wound"]()); gainBuff("Block", 15);
            });
            let pummel = () => new Card("Pummel", 2, "Attack", "Deal [DAM2] damage 6 times.", function(enemy){
                dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);
            });
            let rage = () => new Card("Rage", 0, "Skill", "For each Attack you play this turn, gain [BLK3] Block.", function(enemy){
                gainBuff("Rage", 3);
            });
            let rampage = () => new Card("Rampage", 1, "Attack", "Deal [RAMPAGE] damage. This card deals 5 more damage this combat.", function(enemy){
                dealDamage(enemy, 8 + hasBuff("Rampage")); gainBuff("Rampage", 5);
            });
            let recklessCharge = () => new Card("Reckless Charge",0,"Attack","Deal [DAM7] damage. Get a Dazed card.",function(enemy){
                dealDamage(enemy, 7); discardPile.push(statusCards["Dazed"]());
            });
            let secondWind = () => new Card("Second Wind", 1, "Skill", "Exhaust all non-Attack cards in your hand. Gain [BLK5] Block for each card Exhausted.", function(enemy){
                for(let card of hand) {
                    if(card.type != "Attack") {
                        exhaustPile.push(card);
                        hand.splice(hand.indexOf(card), 1);
                        gainBuff("Block", 5);
                    }
                }
            });
            let seeingRed = () => new Card("Seeing Red", 0, "Skill", "Gain 1 energy. Exhaust.", function(enemy){
                energy += 1;
            }, ["exhausted"]);
            let severSoul = () => new Card("Sever Soul", 2, "Attack", "Exhaust all non-Attack cards in your hand. Deal [DAM16] damage.", function(enemy){
                for(let card of hand) {
                    if(card.type != "Attack") {
                        exhaustPile.push(card);
                        hand.splice(hand.indexOf(card), 1);
                    }
                }
                dealDamage(enemy, 16);
            });
            let spotWeakness = () => new Card("Spot Weakness", 1, "Skill", "If the enemy intends to attack, gain 3 Strength.", function(enemy){
                if(enemy.intent.intent.includes("attack")) {
                    gainBuff("Strength", 3);
                } else {
                    alert("Failed to play Spot Weakness: That enemy does not intend to attack.");
                }
            });
            let uppercut = () => new Card("Uppercut", 2, "Attack", "Deal [DAM13] damage. Apply 1 Weak and Vulnerable.", function(enemy){
                dealDamage(enemy, 13); enemy.gainBuff("Weak", 1); enemy.gainBuff("Vulnerable", 1);
            });
            let whirlwind = () => new Card("Whirlwind", "X", "Attack", "Deal [DAM5] damage to ALL enemies X times.", function(enemy){
                for(let e of enemies){dealDamage(e, 5);}
            });
            
            //
            // Rares
            //
            let barricade = () => new Card("Barricade", 3, "Power", "Block is not removed at the start of your turn.", function(enemy){
                gainBuff("Barricade", 1);
            }, ["exhausted"]);
            let berserk = () => new Card("Berserk", 0, "Power", "Gain Vulnerable for 2 turns, but gain 1 more energy each turn.", function(enemy){
                gainBuff("Vulnerable", 3); gainBuff("Energize", 1);
            }, ["exhausted"]);
            let bludgeon = () => new Card("Bludgeon", 3, "Attack", "Deal [DAM32] damage.", function(enemy){
                dealDamage(enemy, 32);
            });
            let brutality = () => new Card("Brutality", 0, "Power", "At the start of your turn, lose 1 HP and draw 1 more card.", function(enemy){
                gainBuff("Brutality", 1);
            }, ["exhausted"]);
            let demonForm = () => new Card("Demonic Ritual", 3, "Power", "At the end of your turn, gain 2 Strength.", function(enemy){
                gainBuff("Ritual", 2);
            }, ["exhausted"]);
            let doubleTap = () => new Card("Double Tap", 1, "Skill", "Your next Attack is played twice.", function(enemy){
                gainBuff("Double Tap", 1);
            }, ["exhausted"]);
            let exhume = () => new Card("Exhume", 1, "Skill", "Put a card from your exhaust pile in your hand. Exhaust.", async function(enemy){
                let chosen = await choose(exhaustPile, "Choose a card to put into your hand.");
                if(chosen) {
                    hand.push(chosen);
                    exhaustPile.splice(exhaustPile.indexOf(chosen), 1);
                    updateHtml();
                } else {
                    alert("Failed to play Exhume: Exhaust pile is empty.");
                }
            }, ["exhausted"]);
            let feed = () => new Card("Feed", 1, "Attack", "Enemy loses 10 HP. If they die from it, gain 3 Max HP. Exhaust.", function(enemy){
                if(enemy.hp <= 10) {maxHp += 3; hp += 3;}
                enemy.hp -= 10;
            }, ["exhausted"]);
            let impervious = () => new Card("Impervious", 2, "Skill", "Gain [BLK30] block. Exhaust.", function(enemy){
                gainBuff("Block", 30);
            }, ["exhausted"]);
            let juggernaut = () => new Card("Juggernaut", 2, "Power", "Whenever you gain Block, deal [DAM5] damage to a random enemy.", function(enemy){
                gainBuff("Juggernaut", 5);
            }, ["exhausted"]);
            let limitBreak = () => new Card("Limit Break", 1, "Skill", "Double your Strength. Exhaust.", function(enemy){
                if(hasBuff("Strength")>0) {gainBuff("Strength", hasBuff("Strength"));}
            }, ["exhausted"]);
            let offering = () => new Card("Offering", 0, "Skill", "Lose 6 HP. Gain 2 energy. Draw 3 cards. Exhaust.", function(enemy){
                hp -= 6; energy += 2; drawCard(3);
            }, ["exhausted"]);
            let reaper = () => new Card("Reaper", 2, "Attack", "Deal [DAM8] damage. Heal 8 HP. Exhaust.", function(enemy){
                dealDamage(enemy, 8); hp = Math.min(maxHp, hp + 8);
            }, ["exhausted"]);
            
            //
            // Silent Commons
            //
            let acrobatics = () => new Card("Acrobatics", 1, "Skill", "Draw 3 cards. Discard 1 card.", async function(enemy){
                drawCard(3);
                let chosen = await choose(hand.filter(x=>x.name!="Acrobatics"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let backflip = () => new Card("Backflip", 1, "Skill", "Gain [BLK5] Block. Draw 2 cards.", function(enemy){
                gainBuff("Block", 5); drawCard(2);
            });
            let bane = () => new Card("Bane", 1, "Attack", "Deal [DAM7] damage, twice if enemy has Poison.", function(enemy){
                dealDamage(enemy, 7); if(enemy.hasBuff("Poison")) {dealDamage(enemy, 7);}
            });
            let bladeDance = () => new Card("Blade Dance", 1, "Skill", "Add 3 Shivs to your hand.", function(enemy){
                addShivs(3);
            });
            let cloakAndDagger = () => new Card("Cloak and Dagger", 1, "Skill", "Gain [BLK6] Block. Add a Shiv to your hand.", function(enemy){
                gainBuff("Block", 6); addShivs(1);
            });
            let daggerSpray = () => new Card("Dagger Spray", 1, "Attack", "Deal [DAM4] damage to ALL enemies twice.", function(enemy){
                for(let e of enemies){dealDamage(e, 4);dealDamage(e, 4);}
            });
            let daggerThrow = () => new Card("Dagger Throw", 1, "Attack", "Deal [DAM9] damage. Draw a card. Discard a card.", async function(enemy){
                dealDamage(enemy, 9); drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Dagger Throw"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let deadlyPoison = () => new Card("Deadly Poison", 1, "Skill", "Apply 5 Poison.", function(enemy){
                enemy.gainBuff("Poison", 5);
            });
            let deflect = () => new Card("Deflect", 0, "Skill", "Gain [BLK4] Block.", function(enemy){
                gainBuff("Block", 4);
            });
            let dodgeAndRoll = () => new Card("Dodge and Roll", 1, "Skill", "Gain [BLK3] Block. Next turn, gain [BLK6] Block.", function(enemy){
                gainBuff("Block", 3); gainBuff("Next Turn Block", 6);
            });
            let flyingKnee = () => new Card("Flying Knee", 1, "Attack", "Deal [DAM8] damage. Gain 1 more energy next turn.", function(enemy){
                dealDamage(enemy, 8); gainBuff("Next Turn Energy", 1);
            });
            let outmaneuver = () => new Card("Outmaneuver", 1, "Skill", "Gain 2 more energy next turn.", function(enemy){
                gainBuff("Next Turn Energy", 2);
            });
            let poisonedStab = () => new Card("Poisoned Stab", 1, "Attack", "Deal [DAM6] damage. Apply 3 Poison.", function(enemy){
                dealDamage(enemy, 6); enemy.gainBuff("Poison", 3);
            });
            let prepared = () => new Card("Prepared", 0, "Skill", "Draw a card. Discard a card.", async function(enemy){
                drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let quickSlash = () => new Card("Quick Slash", 1, "Attack", "Deal [DAM8] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 8); drawCard();
            });
            let slice = () => new Card("Slice", 0, "Attack", "Deal [DAM6] damage.", function(enemy){
                dealDamage(enemy, 6);
            });
            let suckerPunch = () => new Card("Sucker Punch", 1, "Attack", "Deal [DAM7] damage. Apply 1 Weak.", function(enemy){
                dealDamage(enemy, 7); enemy.gainBuff("Weak", 1);
            });
            
            //
            // Silent Uncommons
            //
            let accuracy = () => new Card("Accuracy", 1, "Power", "Shivs deal 4 more damage.", function(enemy){
                gainBuff("Accuracy", 4);
            }, ["exhausted"]);
            let allOutAttack = () => new Card("All-Out Attack", 1, "Attack", "Deal [DAM10] damage to ALL enemies. Discard a random card.", function(enemy){
                for(let e of enemies) {dealDamage(e,10);}
                let chosen = choice(hand);
                discardPile.push(chosen);
                hand.splice(hand.indexOf(chosen), 1);
            });
            let backstab = () => new Card("Backstab", 0, "Attack", "Innate. Deal [DAM11] damage. Exhaust.", function(enemy){
                dealDamage(enemy, 11);
            }, ["exhausted", "innate"]);
            let blur = () => new Card("Blur", 1, "Skill", "Gain [BLK5] Block. Block is not removed next turn.", function(enemy){
                gainBuff("Blur", 1); gainBuff("Block", 5);
            });
            let bouncingFlask = () => new Card("Bouncing Flask", 2, "Skill", "Apply 9 Poison to a random enemy.", function(enemy){
                choice(enemies).gainBuff("Poison", 9);
            });
            let caltrops = () => new Card("Caltrops", 1, "Skill", "Gain 3 Thorns. Exhaust.", function(enemy){
                gainBuff("Thorns", 3);
            }, ["exhausted"]);
            let catalyst = () => new Card("Catalyst", 1, "Skill", "Double the enemy's Poison. Exhaust.", function(enemy){
                enemy.gainBuff("Poison", enemy.hasBuff("Poison"));
            }, ["exhausted"]);
            
            //
            // Upgraded Cards
            //
            let upgradedCards = {
                "Strike": () => new Card("Strike+", 1, "Attack", "Deal [DAM9] damage.", function(enemy){
                    dealDamage(enemy, 9);
                }), "Defend": () => new Card("Defend+", 1, "Skill", "Gain [BLK8] Block.", function(enemy){
                    gainBuff("Block", 8);
                }), "Bash": () => new Card("Bash+", 2, "Attack", "Deal [DAM10] damage, apply 3 Vulnerable.", function(enemy){
                    dealDamage(enemy, 10); enemy.gainBuff("Vulnerable", 3);
                }), "Body Slam": () => new Card("Body Slam+", 0, "Attack", "Deal damage equal to your Block. ([BLOCK] damage)", function(enemy){
                    dealDamage(enemy, hasBuff("Block"));
                }), "Clash": () => new Card("Clash+", 0, "Attack","Deal [DAM18] damage if all cards in your hand are Attacks.", function(enemy){
                    if(!hand.map(x=>x.type=="Attack").includes(false)) {dealDamage(enemy, 18);}
                }), "Cleave": () => new Card("Cleave+", 1, "Attack", "Deal [DAM11] damage to ALL enemies.", function(enemy){
                    for(let e of enemies){dealDamage(e, 11);}
                }), "Clothesline": () => new Card("Clothesline+", 2, "Attack", "Deal [DAM14] damage, apply 3 Weak.", function(enemy){
                    dealDamage(enemy, 14); enemy.gainBuff("Weak", 3);
                }), "Flex": () => new Card("Flex+", 0, "Skill", "Gain 4 Strength. At the end of your turn, lose 4 Strength.", function(enemy){
                    gainBuff("Strength", 4); gainBuff("Strength Down", 4);
                }), "Headbutt": () => new Card("Headbutt", 1, "Attack", "Deal [DAM12] damage. Put a card from your discard pile on top of your draw pile.", async function(enemy){
                    dealDamage(enemy, 12);
                    let chosen = await choose(discardPile, "Choose a card to put on top of your Draw Pile.");
                    if(chosen) {
                        drawPile = [chosen, ...drawPile];
                        discardPile.splice(discardPile.indexOf(chosen), 1);
                        updateHtml();
                    }
                }), "Heavy Blade": () => new Card("Heavy Blade+", 2, "Attack", "Deal [HEAVYBLADE+] damage. Strength affects the damage 5 times.", function(enemy){
                    dealDamage(enemy, 14 + 4 * hasBuff("Strength"));
                }), "Iron Wave": () => new Card("Iron Wave+", 1, "Attack", "Gain [BLK7] Block. Deal [DAM7] damage.", function(enemy){
                    dealDamage(enemy, 7); gainBuff("Block", 7);
                }), "Pommel Strike": () => new Card("Pommel Strike+", 1, "Attack", "Deal [DAM10] damage. Draw 2 cards.", function(enemy){
                    dealDamage(enemy, 10); drawCard(2);
                }), "Shrug it Off": () => new Card("Shrug it Off+", 1, "Skill", "Gain [BLK11] Block. Draw a card.", function(enemy){
                    gainBuff("Block", 11); drawCard();
                }), "Sword Boomerang": () => new Card("Sword Boomerang+", 1, "Attack", "Deal [DAM3] damage to a random enemy 4 times.", function(enemy){
                    dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3);
                }), "Thunderclap": () => new Card("Thunderclap+", 1, "Attack", "Deal [DAM7] damage and apply 1 Vulnerable to ALL enemies.", function(enemy){
                    for(let e of enemies){dealDamage(e, 7); e.gainBuff("Vulnerable", 1);}
                }), "True Grit": () => new Card("True Grit+", 1, "Skill", "Gain [BLK7] Block. Exhaust a card in your hand.", async function(enemy){
                    gainBuff("Block", 7);
                    let chosen = await choose(hand, "Choose a card to Exhaust.");
                    if(chosen) {
                        hand.splice(hand.indexOf(chosen), 1);
                        exhaustPile.push(chosen);
                        updateHtml();
                    }
                }), "Twin Strike": () => new Card("Twin Strike+", 1, "Attack", "Deal [DAM7] damage twice.", function(enemy){
                    dealDamage(enemy, 7); dealDamage(enemy, 7);
                }), "Wild Strike": () => new Card("Wild Strike+", 1, "Attack", "Deal [DAM17] damage. Shuffle a Wound into your discard pile.", function(enemy){
                    dealDamage(enemy, 17); discardPile.push(statusCards["Wound"]());
                }), "Battle Trance": () => new Card("Battle Trance+", 0, "Skill", "Draw 4 cards. You cannot draw additional cards this turn.", function(enemy){
                    drawCard(4); gainBuff("No Draw", 1);
                }), "Blood for Blood": () => new Card("Blood for Blood+", 4, "Attack", "Deal [DAM26] damage. -1 cost each time you lose HP. (Costs [BLOOD4BLOOD] energy)", function(enemy){
                    dealDamage(enemy, 26);
                }, ["blood4blood"]), "Bloodletting": () => new Card("Bloodletting+", 0, "Skill", "Lose 3 HP. Gain 3 energy.", function(enemy){
                    hp -= 3; energy += 3;
                }), "Burning Pact": () => new Card("Burning Pact+", 1, "Skill", "Exhaust 1 card. Draw 3 cards.", async function(enemy){
                    let chosen = await choose(hand, "Choose a card to Exhaust.");
                    if(chosen) {
                        hand.splice(hand.indexOf(chosen), 1);
                        exhaustPile.push(chosen);
                        drawCard(3);
                        updateHtml();
                    } else {
                        alert("Failed to play Burning Pact: No remaining cards in hand.");
                    }
                }), "Carnage": () => new Card("Carnage+", 2, "Attack", "Ethereal. Deal [DAM28] damage.", function(enemy){
                    dealDamage(enemy, 28);
                }, ["ethereal"]), "Combust": () => new Card("Combust+", 1, "Power", "At the end of your turn, lose 1 HP and deal 7 damage to ALL enemies.", function(enemy){
                    gainBuff("Combust", 7);
                }, ["exhausted"]), "Dark Embrace+": () => new Card("Dark Embrace+", 1, "Power", "Whenever a card is Exhausted, draw a card.", function(enemy){
                    gainBuff("Dark Embrace", 1);
                }, ["exhausted"]), "Disarm": () => new Card("Disarm+", 1, "Skill", "Enemy gets -3 Strength. Exhaust.", function(enemy){
                    enemy.gainBuff("Minus Strength", 3);
                }, ["exhausted"]), "Dropkick": () => new Card("Dropkick+", 1, "Attack", "Deal [DAM8] damage. If the enemy has Vulnerable, gain 1 energy and draw a card.", function(enemy){
                    dealDamage(enemy, 8);
                    if(enemy.hasBuff("Vulnerable") > 0) {
                        energy++;
                        drawCard();
                    }
                }), "Dual Wield": () => new Card("Dual Wield+", 1, "Skill", "Create 2 copies of an Attack or Power card in your hand.", async function(enemy){
                    let chosen = await choose(hand.filter(x=>["Attack","Power"].includes(x.type)), "Choose a card to copy.");
                    if(chosen) {
                        hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use));
                        hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use));
                        updateHtml();
                    } else {
                        alert("Failed to play Dual Wield: No Attack or Power cards in hand.");
                    }
                }), "Entrench": () => new Card("Entrench+", 1, "Skill", "Double your Block.", function(enemy){
                    if(hasBuff("Block")>0) {gainBuff("Block", hasBuff("Block"));}
                }), "Evolve": () => new Card("Evolve+", 1, "Power", "Whenever you draw a Status card, draw 2 more cards.", function(enemy){
                    gainBuff("Evolve", 2);
                }, ["exhausted"]), "Feel No Pain": () => new Card("Feel No Pain+", 1, "Power", "When a card is Exhausted, gain [BLK4] Block.", function(enemy){
                    gainBuff("Feel No Pain", 4);
                }, ["exhausted"]), "Fire Breathing": () => new Card("Fire Breathing+", 1, "Power", "Whenever you draw a Status card, deal 10 damage to ALL enemies", function(enemy){
                    gainBuff("Fire Breathing", 10);
                }, ["exhausted"]), "Flame Barrier": () => new Card("Flame Barrier+", 2, "Skill", "Gain [BLK16] Block and 3 Thorns.", function(enemy){
                    gainBuff("Block", 16); gainBuff("Thorns", 3);
                }), "Ghostly Armor": () => new Card("Ghostly Armor+", 1, "Skill", "Ethereal. Gain [BLK13] Block.", function(enemy){
                    gainBuff("Block", 13);
                }, ["ethereal"]), "Hemokinesis": () => new Card("Hemokinesis+", 1, "Attack", "Lose 2 HP. Deal [DAM20] damage.", function(enemy){
                    hp -= 2; dealDamage(enemy, 20);
                }), "Infernal Blade": () => new Card("Infernal Blade+", 0, "Skill", "Add 2 random Attacks to your hand. Exhaust", function(enemy){
                    let extraCard = randCard()(); // looks weird ik
                    while(extraCard.type != "Attack") {extraCard = randCard()();}
                    hand.push(extraCard);
                    let extraCard2 = randCard()(); // looks weird ik
                    while(extraCard2.type != "Attack") {extraCard2 = randCard()();}
                    hand.push(extraCard2);
                }, ["exhausted"]), "Enflame": () => new Card("Enflame+", 1, "Power", "Gain 3 Strength.", function(enemy){
                    gainBuff("Strength", 3);
                }, ["exhausted"]), "Intimidate": () => new Card("Intimidate+", 0, "Skill", "Apply 2 Weak to ALL enemies. Exhaust.", function(enemy){
                    for(let e of enemies) {e.gainBuff("Weak", 2);}
                }, ["exhausted"]), "Metallicize": () => new Card("Metallicize+", 1, "Power", "Start each turn with [BLK4] Block.", function(enemy){
                    gainBuff("Metallicize", 4);
                }, ["exhausted"]), "Power Through": () => new Card("Power Through+", 1, "Skill", "Add 2 Wounds to your hand. Gain [BLK20] Block.", function(enemy){
                    hand.push(statusCards["Wound"]()); hand.push(statusCards["Wound"]()); gainBuff("Block", 20);
                }), "Pummel": () => new Card("Pummel+", 2, "Attack", "Deal [DAM2] damage 8 times.", function(enemy){
                    dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2);
                }), "Rage": () => new Card("Rage+", 0, "Skill", "For each Attack you play this turn, gain [BLK5] Block.", function(enemy){
                    gainBuff("Rage", 5);
                }), "Rampage": () => new Card("Rampage+", 1, "Attack", "Deal [RAMPAGE] damage. This card deals 8 more damage this combat.", function(enemy){
                    dealDamage(enemy, 8 + hasBuff("Rampage")); gainBuff("Rampage", 8);
                }), "Reckless Charge": () => new Card("Reckless Charge+", 0, "Attack","Deal [DAM10] damage. Get a Dazed card.", function(enemy){
                    dealDamage(enemy, 10); discardPile.push(statusCards["Dazed"]());
                }), "Second Wind": () => new Card("Second Wind+", 1, "Skill", "Exhaust all non-Attack cards in your hand. Gain [BLK7] Block for each card Exhausted.", function(enemy){
                    for(let card of hand) {
                        if(card.type != "Attack") {
                            exhaustPile.push(card);
                            hand.splice(hand.indexOf(card), 1);
                            gainBuff("Block", 7);
                        }
                    }
                }), "Seeing Red": () => new Card("Seeing Red+", 0, "Skill", "Gain 2 energy. Exhaust.", function(enemy){
                    energy += 2;
                }, ["exhausted"]), "Sever Soul": () => new Card("Sever Soul+", 2, "Attack", "Exhaust all non-Attack cards in your hand. Deal [DAM22] damage.", function(enemy){
                    for(let card of hand) {
                        if(card.type != "Attack") {
                            exhaustPile.push(card);
                            hand.splice(hand.indexOf(card), 1);
                        }
                    }
                    dealDamage(enemy, 22);
                }), "Spot Weakness": () => new Card("Spot Weakness+", 1, "Skill", "If the enemy intends to attack, gain 4 Strength.", function(enemy){
                    if(enemy.intent.intent.includes("attack")) {
                        gainBuff("Strength", 4);
                    } else {
                        alert("That enemy does not intend to attack.");
                    }
                }), "Uppercut": () => new Card("Uppercut+", 2, "Attack", "Deal [DAM13] damage. Apply 2 Weak and Vulnerable.", function(enemy){
                    dealDamage(enemy, 13); enemy.gainBuff("Weak", 2); enemy.gainBuff("Vulnerable", 2);
                }), "Whirlwind": () => new Card("Whirlwind+", "X", "Attack", "Deal [DAM8] damage to ALL enemies X times.", function(enemy){
                    for(let e of enemies){dealDamage(e, 8);}
                }), "Barricade": () => new Card("Barricade+", 2, "Power", "Block is not removed at the start of your turn.", function(enemy){
                    gainBuff("Barricade", 1);
                }, ["exhausted"]), "Berserk": () => new Card("Berserk+", 0, "Power", "Gain Vulnerable for 1 turn, but gain 1 more energy each turn.", function(enemy){
                    gainBuff("Vulnerable", 2); gainBuff("Energize", 1);
                }, ["exhausted"]), "Bludgeon": () => new Card("Bludgeon+", 3, "Attack", "Deal [DAM42] damage.", function(enemy){
                    dealDamage(enemy, 42);
                }), "Brutality": new Card("Brutality+", 0, "Power", "Innate. At the start of your turn, lose 1 HP and draw 1 more card.", function(enemy){
                    gainBuff("Brutality", 1);
                }, ["exhausted", "innate"]), "Demonic Ritual": () => new Card("Demonic Ritual+", 3, "Power", "At the end of your turn, gain 3 Strength.", function(enemy){
                    gainBuff("Ritual", 3);
                }, ["exhausted"]), "Double Tap": () => new Card("Double Tap+", 1, "Skill", "Your next Attack is played 3 times.", function(enemy){
                    gainBuff("Double Tap", 2);
                }, ["exhausted"]), "Exhume": () => new Card("Exhume+", 0, "Skill", "Put a card from your exhaust pile in your hand. Exhaust.", async function(enemy){
                    let chosen = await choose(exhaustPile, "Choose a card to put into your hand.");
                    if(chosen) {
                        hand.push(chosen);
                        exhaustPile.splice(exhaustPile.indexOf(chosen), 1);
                        updateHtml();
                    } else {
                        alert("Failed to play Exhume: Exhaust pile is empty.");
                    }
                }, ["exhausted"]), "Feed": () => new Card("Feed+", 1, "Attack", "Enemy loses 12 HP. If they die from it, gain 4 Max HP. Exhaust.", function(enemy){
                    if(enemy.hp <= 12) {maxHp += 4; hp += 4;}
                    enemy.hp -= 12;
                }, ["exhausted"]), "Impervious": () => new Card("Impervious+", 2, "Skill", "Gain [BLK40] block. Exhaust.", function(enemy){
                    gainBuff("Block", 40);
                }, ["exhausted"]), "Juggernaut": () => new Card("Juggernaut+", 2, "Power", "Whenever you gain Block, deal [DAM7] damage to a random enemy.", function(enemy){
                    gainBuff("Juggernaut", 7);
                }, ["exhausted"]), "Limit Break": () => new Card("Limit Break+", 1, "Skill", "Double your Strength.", function(enemy){
                    if(hasBuff("Strength")>0) {gainBuff("Strength", hasBuff("Strength"));}
                }), "Offering": () => new Card("Offering+", 0, "Skill", "Lose 6 HP. Gain 2 energy. Draw 5 cards. Exhaust.", function(enemy){
                    hp -= 6; energy += 2; drawCard(5);
                }, ["exhausted"]), "Reaper": () => new Card("Reaper", 2, "Attack", "Deal [DAM10] damage. Heal 10 HP. Exhaust.", function(enemy){
                    dealDamage(enemy, 10); hp = Math.min(maxHp, hp + 10);
                }, ["exhausted"]), "Acrobatics": () => new Card("Acrobatics+", 1, "Skill", "Draw 4 cards. Discard 1 card.", async function(enemy){
                drawCard(4);
                let chosen = await choose(hand.filter(x=>x.name!="Acrobatics+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            }), "Backflip": () => new Card("Backflip+", 1, "Skill", "Gain [BLK8] Block. Draw 2 cards.", function(enemy){
                gainBuff("Block", 8); drawCard(2);
            }), "Bane": () => new Card("Bane+", 1, "Attack", "Deal [DAM10] damage, twice if enemy has Poison.", function(enemy){
                dealDamage(enemy, 10); if(enemy.hasBuff("Poison")) {dealDamage(enemy, 10);}
            }), "Blade Dance": () => new Card("Blade Dance+", 1, "Skill", "Add 4 Shivs to your hand.", function(enemy){
                addShivs(4);
            }), "Cloak and Dagger": () => new Card("Cloak and Dagger+", 1, "Skill", "Gain [BLK6] Block. Add 2 Shivs to your hand.", function(enemy){
                gainBuff("Block", 6); addShivs(2);
            }), "Dagger Spray": () => new Card("Dagger Spray+", 1, "Attack", "Deal [DAM6] damage to ALL enemies twice.", function(enemy){
                for(let e of enemies){dealDamage(e, 6);dealDamage(e, 6);}
            }), "Dagger Throw": () => new Card("Dagger Throw+", 1, "Attack", "Deal [DAM12] damage. Draw a card. Discard a card.", async function(enemy){
                dealDamage(enemy, 12); drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Dagger Throw+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            }), "Deadly Poison": () => new Card("Deadly Poison+", 1, "Skill", "Apply 7 Poison.", function(enemy){
                enemy.gainBuff("Poison", 7);
            }), "Deflect": () => new Card("Deflect+", 0, "Skill", "Gain [BLK7] Block.", function(enemy){
                gainBuff("Block", 7);
            }), "Dodge and Roll": () => new Card("Dodge and Roll+", 1, "Skill", "Gain [BLK5] Block. Next turn, gain [BLK8] Block.", function(enemy){
                gainBuff("Block", 5); gainBuff("Next Turn Block", 8);
            }), "Flying Knee": () => new Card("Flying Knee+", 1, "Attack", "Deal [DAM11] damage. Gain 1 more energy next turn.", function(enemy){
                dealDamage(enemy, 11); gainBuff("Next Turn Energy", 1);
            }), "Outmaneuver": () => new Card("Outmaneuver+", 1, "Skill", "Gain 3 more energy next turn.", function(enemy){
                gainBuff("Next Turn Energy", 3);
            }), "Poisoned Stab": () => new Card("Poisoned Stab+", 1, "Attack", "Deal [DAM8] damage. Apply 4 Poison.", function(enemy){
                dealDamage(enemy, 8); enemy.gainBuff("Poison", 4);
            }), "Prepared": () => new Card("Prepared+", 0, "Skill", "Draw 2 cards. Discard 2 cards.", async function(enemy){
                drawCard(2);
                let chosen = await choose(hand.filter(x=>x.name!="Prepared+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared+"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
            }), "Quick Slash": () => new Card("Quick Slash+", 1, "Attack", "Deal [DAM12] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 12); drawCard();
            }), "Slice": () => new Card("Slice+", 0, "Deal [DAM9] damage.", function(enemy){
                dealDamage(enemy, 9);
            }), "Sucker Punch": () => new Card("Sucker Punch+", 1, "Attack", "Deal [DAM9] damage. Apply 2 Weak.", function(enemy){
                dealDamage(enemy, 9); enemy.gainBuff("Weak", 2);
            }), "Accuracy": () => new Card("Accuracy+", 1, "Power", "Shivs deal 6 more damage.", function(enemy){
                gainBuff("Accuracy", 6);
            }, ["exhausted"]), "All-Out Attack": () => new Card("All-Out Attack+", 1, "Attack", "Deal [DAM14] damage to ALL enemies. Discard a random card.", function(enemy){
                for(let e of enemies) {dealDamage(e, 14);}
                let chosen = choice(hand);
                discardPile.push(chosen);
                hand.splice(hand.indexOf(chosen), 1);
            }), "Backstab": () => new Card("Backstab+", 0, "Attack", "Innate. Deal [DAM15] damage. Exhaust.", function(enemy){
                dealDamage(enemy, 15);
            }, ["exhausted", "innate"]), "Blur": () => new Card("Blur+", 1, "Skill", "Gain [BLK8] Block. Block is not removed next turn.", function(enemy){
                gainBuff("Blur", 1); gainBuff("Block", 8);
            }), "Bouncing Flask": () => new Card("Bouncing Flask+", 2, "Skill", "Apply 12 Poison to a random enemy.", function(enemy){
                choice(enemies).gainBuff("Poison", 12);
            }), "Caltrops": () => new Card("Caltrops+", 1, "Skill", "Gain 5 Thorns. Exhaust.", function(enemy){
                gainBuff("Thorns", 5);
            }, ["exhausted"]), "Catalyst": () => new Card("Catalyst+", 1, "Skill", "Triple the enemy's Poison. Exhaust.", function(enemy){
                enemy.gainBuff("Poison", enemy.hasBuff("Poison") * 2);
            }, ["exhausted"])
            };
            function upgradeCard(c) {
                let newCard = upgradedCards[c.name];
                deck.splice(deck.indexOf(c), 1);
                deck.push(newCard());
            }
            let cardToUpgrade;
            async function upgradeDialog() {
                let chosen = await choose(deck.filter(x=>(!x.name.includes("+"))), "Choose a card to upgrade.");
                cardToUpgrade = chosen;
                getId("upgradeDialog").style.display = "block";
                getId("cardDesc").innerHTML = "Upgrading <b>"+cardToUpgrade.name+"</b>:<br/><span style='color:#faa'>Old</span>: "+addCircle(cardToUpgrade.cost.toString())+" | "+unformat(cardToUpgrade.desc)+"<br/><span style='color:#afa'>New</span>: "+addCircle(upgradedCards[cardToUpgrade.name]().cost.toString())+" | "+unformat(upgradedCards[cardToUpgrade.name]().desc);
            }
            
            let randCard = () => choice([bodySlam, clash, cleave, clothesline, flex, headbutt, heavyBlade, ironWave, pommelStrike, shrugItOff, swordBoomerang, thunderclap, trueGrit, twinStrike, wildStrike, battleTrance, bloodForBlood, bloodletting, burningPact, carnage, combust, darkEmbrace, disarm, dropkick, dualWield, entrench, evolve, feelNoPain, fireBreathing, flameBarrier, ghostlyArmor, hemokinesis, infernalBlade, inflame, intimidate, metallicize, powerThrough, pummel, rage, rampage, secondWind, seeingRed, severSoul, spotWeakness, uppercut, whirlwind, acrobatics, backflip, bane, bladeDance, cloakAndDagger, daggerSpray, daggerThrow, deadlyPoison, deflect, dodgeAndRoll, flyingKnee, outmaneuver, poisonedStab, prepared, quickSlash, slice, suckerPunch, accuracy, allOutAttack, backstab, blur, bouncingFlask, caltrops, catalyst]);
            let randRareCard = () => choice([barricade, berserk, bludgeon, brutality, demonForm, doubleTap, exhume, feed, impervious, juggernaut, limitBreak, offering, reaper]);
            
            function addCard(newCards="random") {
                if(newCards == "random") {
                    if(eliteBattle == true || bossBattle == true) {
                        newCards = [randRareCard()(), randRareCard()(), randRareCard()()];
                    } else {
                        newCards = [randCard()(), randCard()(), randCard()()];
                    }
                }
                possibleCards = newCards;
                getId("cardModal").style.display = "block";
                for(let x=0; x<3; x++) {
                    let cardTooltip = document.createElement("span");
                    let modalCard = getId("modalCard"+(x+1));
                    modalCard.innerHTML = newCards[x].name;
                    cardTooltip.innerHTML = addCircle(newCards[x].cost.toString())+" "+newCards[x].type+" | "+unformat(newCards[x].desc);
                    cardTooltip.setAttribute("class", "txt");
                    modalCard.appendChild(cardTooltip);
                }
            };
            function finishAddCard(cardNumber) {
                if(cardNumber >= 0 && cardNumber < possibleCards.length) {
                    let c = possibleCards[cardNumber];
                    if(!c || !c.name) {
                        alert("something is broken, the picked card doesn't seem to exist");
                    }
                    if(!c.use) {
                        alert("card added (" + c.name + ") doesn't have a use() function!!");
                    }
                    deck.push(c);
                    for(let r of relics) {if(r.trigger == "add_card") {r.effect();}}
                    updateStatLine();
                } else if(cardNumber == -1) {
                    for(let r of relics) {if(r.trigger == "no_card") {r.effect();}}
                    updateStatLine();
                } else {
                    alert("got to impossible place when adding a card");
                }
            }
            
            function addBossRelic(newCards="random") {
                if(newCards == "random") {
                    newCards = [choice(rareRelicPool)(), choice(rareRelicPool)(), choice(rareRelicPool)()];
                }
                possibleCards = newCards;
                getId("bossModal").style.display = "block";
                for(let x=0; x<3; x++) {
                    let cardTooltip = document.createElement("span");
                    let modalCard = getId("modalRelic"+(x+1));
                    modalCard.innerHTML = newCards[x].name;
                    cardTooltip.innerHTML = newCards[x].desc;
                    cardTooltip.setAttribute("class", "txt");
                    modalCard.appendChild(cardTooltip);
                }
            };
            function finishAddRelic(cardNumber) {
                if(cardNumber >= 0 && cardNumber < possibleCards.length) {
                    let r = possibleCards[cardNumber];
                    relics.push(r);
                    if(r.trigger == "on_pickup") {r.effect();}
                    updateStatLine();
                } else {
                    alert("error in logic of adding boss relic");
                }
            }
            
            let offers = [];
            let possibleCards = [];
            
            function r_snakeRing() {drawCard(2);}
            function r_akabeko() {gainBuff("Strength", 8); gainBuff("Vigor", 8);}
            function r_anchor() {gainBuff("Block", 10);}
            function r_tea() {energy += 2;}
            function r_artOfWar() {energy += 1;}
            function r_bagOfMarbles() {for(let x of enemies){x.gainBuff("Vulnerable",1);}}
            function r_bloodVial() {hp = Math.min(maxHp, hp+2);}
            function r_bronzeScales() {gainBuff("Thorns", 3);}
            function r_ceramicFish() {gold += 9;}
            function r_nunchaku() {if(Math.random()<0.1){energy += 1;}}
            function r_smoothStone() {gainBuff("Dexterity", 1);}
            function r_orichalcum() {if(hasBuff("Block")==0){gainBuff("Block", 6);}}
            function r_penNib() {gainBuff("Pen Nib", 1); if(hasBuff("Pen Nib") >= 10) {loseBuff("Pen Nib"); dealDamage(target, 10);}}
            function r_preservedInsect() {if(eliteBattle==true){dealDamage(target,Math.round(0.25*target.hp));}}
            function r_regalPillow() {hp = Math.min(maxHp, hp+15);}
            function r_strawberry() {maxHp += 7; hp += 7;}
            function r_vajra() {gainBuff("Strength", 1);}
            function r_feather() {hp = Math.min(maxHp, hp+Math.round(0.5*deck.length));}
            function r_frozenEgg() {if(deck[deck.length-1].type=="Power"){upgradeCard(deck[deck.length-1]);}}
            function r_letterOpener() {for(let x of enemies){dealDamage(x, 5);}}
            function r_meatBone() {if(hp/maxHp <= 0.5) {hp = Math.min(maxHp, hp+12);}}
            function r_mercuryHourglass() {for(let x of enemies){dealDamage(x, 3);}}
            function r_moltenEgg() {if(deck[deck.length-1].type=="Attack"){upgradeCard(deck[deck.length-1]);}}
            function r_ornamentalFan() {gainBuff("Block", 4);}
            function r_pear() {maxHp += 10; hp += 10;}
            function r_selfFormingClay() {gainBuff("Next Turn Block", 3);}
            function r_singingBowl() {maxHp += 2; hp += 2;}
            function r_strikeDummy() {dealDamage(target, 3);}
            function r_toxicEgg() {if(deck[deck.length-1].type=="Skill"){upgradeCard(deck[deck.length-1]);}}
            function r_birdFacedUrn() {hp = Math.min(maxHp, hp+2);}
            function r_championsBelt() {target.gainBuff("Weak", 1);}
            function r_deadBranch() {hand.push(randCard()());}
            function r_helixFossil() {gainBuff("Buffer", 1);}
            function r_mango() {maxHp += 14; hp += 14;}
            function r_oldCoin() {gold += 300;}
            function r_threadAndNeedle() {gainBuff("Metallicize", 3);}
            let relicPool = [
                () => new Relic("Akabeko","Your first attack each combat deals 8 more damage.","combat_start",r_akabeko),
                () => new Relic("Anchor","Start each combat with 10 Block","combat_start",r_anchor),
                () => new Relic("Ancient Tea Set","When you enter a Rest Site, start the next combat with 2 more energy.","rest",r_tea),
                () => new Relic("Art of War","If you play no attacks in a turn, gain 1 energy next turn.","no_attacks",r_artOfWar),
                () => new Relic("Bag of Marbles","ALL enemies start combat with 1 Vulnerable.","combat_start",r_bagOfMarbles),
                () => new Relic("Blood Vial","At start of combat, heal 2 HP.","combat_start",r_bloodVial),
                () => new Relic("Bronze Scales","When you take damage, deal 3 damage back.","combat_start",r_bronzeScales),
                () => new Relic("Ceramic Fish","When you add a card to your deck, gain 9 gold.","add_card",r_ceramicFish),
                () => new Relic("Lantern","Gain 1 energy at the start of each combat.","combat_start",r_artOfWar),
                () => new Relic("Nunchaku","When you play an Attack, 10% chance to gain 1 energy.","on_attack",r_nunchaku),
                () => new Relic("Oddly Smooth Stone","Start each combat with 1 Dexterity.","combat_start",r_smoothStone),
                () => new Relic("Orichalcum","When you end your turn without Block, gain 6 Block.","turn_end",r_orichalcum),
                () => new Relic("Pen Nib","Every 10th Attack you play deals 10 more damage.","on_attack",r_penNib),
                () => new Relic("Preserved Insect","Elites have 25% less HP.","combat_start",r_preservedInsect),
                () => new Relic("Regal Pillow","When you leave a Rest Site, heal 15 HP.","rest",r_regalPillow),
                () => new Relic("Strawberry","Raise your max HP by 7 and heal 7 HP.","on_pickup",r_strawberry),
                () => new Relic("Vajra","Start each combat with 1 Strength.","combat_start",r_vajra),
                () => new Relic("Eternal Feather","When you rest, heal 1 HP for each 2 cards in your deck.","rest",r_feather),
                () => new Relic("Frozen Egg","When you add a Power to your deck, it is upgraded.","add_card",r_frozenEgg),
                () => new Relic("Ice Cream","You can keep excess energy between turns.","special",function(){}),
                () => new Relic("Kunai","When you play 3 Attacks in a single turn, gain 1 Dexterity.","3_attacks",r_smoothStone),
                () => new Relic("Letter Opener","When you play 3 Skills in a single turn, deal 5 damage to ALL enemies.","3_skills",r_letterOpener),
                () => new Relic("Meat on the Bone","When you start combat with under 50% HP, heal 12 HP.","combat_start",r_meatBone),
                () => new Relic("Mercury Hourglass","At start of turn, deal 3 damage to ALL enemies.","turn_start",r_mercuryHourglass),
                () => new Relic("Molten Egg","When you add an Attack to your deck, it is upgraded.","add_card",r_moltenEgg),
                () => new Relic("Ornamental Fan","When you play 3 Attacks in a single turn, gain 4 Block.","3_attacks",r_ornamentalFan),
                () => new Relic("Pear","Raise your max HP by 10 and heal 10 HP.","on_pickup",r_pear),
                () => new Relic("Self-Forming Clay","When you lose HP in combat, gain 3 Block next turn.","lose_hp",r_selfFormingClay),
                () => new Relic("Shuriken","When you play 3 Attacks in a single turn, gain 1 Strength.","3_attacks",r_vajra),
                () => new Relic("Singing Bowl","When you view but decline the card reward, gain 2 Max HP.","no_card",r_singingBowl),
                () => new Relic("Strike Dummy","Cards containing 'Strike' deal 3 more damage.","strike",r_strikeDummy),
                () => new Relic("Toxic Egg","When you add a Skill to your deck, it is upgraded.","add_card",r_toxicEgg)
            ];
            let rareRelicPool = [
                () => new Relic("Bird-Faced Urn","When you play a Power, heal 2 HP.","on_power",r_birdFacedUrn),
                () => new Relic("Champion's Belt","When you apply Vulnerable, also apply 1 Weak.","apply_vulnerable",r_championsBelt),
                () => new Relic("Charon's Ashes","When you Exhaust a card, deal 3 damage to ALL enemies.",r_mercuryHourglass),
                () => new Relic("Dead Branch","When you Exhaust a card, add a random card to your hand.","on_exhaust",r_deadBranch),
                () => new Relic("Fossilized Helix","Prevent the first HP loss each combat.","combat_start",r_helixFossil),
                () => new Relic("Mango","Raise your max HP by 14 and heal 14 HP.","on_pickup",r_mango),
                () => new Relic("Old Coin","Instantly gain 300 gold.","on_pickup",r_oldCoin),
                () => new Relic("Thread and Needle","Start each combat with 3 Metallicize.","combat_start",r_threadAndNeedle)
            ];
            
            let potionPool = [
                {name: "Block", desc: "Gain 12 Block.", effect: "gainBuff('Block', 12)"},
                {name: "Blood", desc: "Heal for 20% of your Max HP.", effect: "hp = Math.min(maxHp, hp + Math.round(0.2 * maxHp))"},
                {name: "Cultist", desc: "Gain 1 Ritual.", effect: "gainBuff('Ritual', 1)"},
                {name: "Dexterity", desc: "Gain 2 Dexterity.", effect: "gainBuff('Dexterity', 2)"},
                {name: "Energy", desc: "Gain 2 energy.", effect: "energy += 2"},
                {name: "Iron", desc: "Gain 3 Metallicize.", effect: "gainBuff('Metallicize', 3)"},
                {name: "Explosive", desc: "Deal 10 damage to ALL enemies.", effect: "for(let e of enemies){dealDamage(e, 10);}"},
                {name: "Fear", desc: "Apply 3 Vulnerable to target.", effect: "tgt.gainBuff('Vulnerable', 3)"},
                {name: "Fire", desc: "Deal 20 damage to target.", effect: "dealDamage(tgt, 20)"},
                {name: "Flex", desc: "Gain 5 Strength. At end of turn, lose 5 Strength.", effect: "gainBuff('Strength', 5); gainBuff('Strength Down', 5)"},
                {name: "Fruit Juice", desc: "Gain 5 Max HP.", effect: "maxHp += 5; hp += 5"},
                {name: "Steel", desc: "Gain 5 Metallicize.", effect: "gainBuff('Metallicize', 5)"},
                {name: "Bronze", desc: "Gain 3 Thorns.", effect: "gainBuff('Thorns', 3)"},
                {name: "Regen", desc: "Gain 5 Regen.", effect: "gainBuff('Regen', 5)"},
                {name: "Speed", desc: "Gain 5 Dexterity. At end of turn, lose 5 Dexterity.", effect: "gainBuff('Dexterity', 5); gainBuff('Dexterity Down', 5)"},
            ];
            
            let deck = [strike(), strike(), strike(), strike(), bash(), defend(), defend(), defend(), defend(), defend()];
            let relics = [new Relic("Ring of the Snake","At the start of each combat, draw 2 additional cards.","combat_start",r_snakeRing)];
            let potions = [];
            let drawPile = shuffle(deck.slice(0)); // no shallow copy
            let discardPile = [];
            let exhaustPile = [];
            let hand = [];
            let energy = 3;
            let maxEnergy = 3;
            let hp = 70;
            let maxHp = 70;
            let buffs = [];
            let stats = {timesLostHp: 0, hasAttacked: false, attacksThisTurn: 999, skillsThisTurn: 999, rested: false};
            let gold = 0;
            let mapX = 2;
            let mapY = 0;
            let actNum = 1;
            let randomThing = () => choice(["enemy", "enemy", "enemy", "enemy", "shop&nbsp;", "elite", "rest&nbsp;"]);
            function maybeThing() {if(Math.random()<0.6){return randomThing();}else{return "";}}
            let map;
            function mapGen() {
                map = [
                ["",            "",            "start",       "",            ""          ],
                ["",            randomThing(), randomThing(), randomThing(), ""          ],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                ["",            "rest&nbsp;",  "rest&nbsp;",  "rest&nbsp;",  ""          ],
                ["",            "","<b style='color:red'>BOSS&nbsp;</b>","", ""          ]
            ];
            }
            mapGen();
            
            // These make writing attacks *much* easier.
            let attack = amt => function(me){ me.dealDamage(amt); }
            let block = amt => function(me){ me.gainBuff("Block", amt); }
            let block_random = amt => function(me){ choice(enemies).gainBuff("Block", amt); }
            let buff = (what, amt) => function(me){ me.gainBuff(what, amt); }
            let all_buff = (what, amt) => function(me){ for(let e of enemies){e.gainBuff(what, amt);}}
            let apply = (what, amt) => function(me){ gainBuff(what, amt); }
            let status = (what, amt) => function(me){ for(let x=0; x<amt; x++) {discardPile.push(statusCards[what]()); log(me.name+" generated a "+what);} }
            let multi_apply = (lst) => function(me){ for(let x of lst){gainBuff(x[0], x[1]);} }
            let multi_buff = (lst) => function(me){ for(let x of lst){me.gainBuff(x[0], x[1]);} }
            let attack_block = (atk, blk) => function(me){ me.dealDamage(atk); me.gainBuff("Block", blk); }
            let attack_apply = (atk, what, amt) => function(me){ me.dealDamage(atk); gainBuff(what, amt); }
            let attack_buff = (atk, what, amt) => function(me){ me.dealDamage(atk); me.gainBuff(what, amt); }
            let block_buff = (blk, what, amt) => function(me){ me.gainBuff("Block", blk); me.gainBuff(what, amt); }
            let block_multinerf = (blk, lst) => function(me){ me.gainBuff("Block", blk); for(let x of lst){gainBuff(x[0], x[1]);}}
            let attack_status = (atk, what, amt) => function(me){ for(let x=0; x<amt; x++) {discardPile.push(statusCards[what]()); log(me.name+" generated a "+what);} me.dealDamage(atk); }
            let buff_apply = (b, bamt, n, namt) => function(me){ me.gainBuff(b, bamt); gainBuff(n, namt); }
            
            let possibleEnemies = [
                () => new Enemy("Cultist", 50, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 3)},
                    {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
                ], ["no-repeat"]),
                () => new Enemy("Jaw Worm", 40, [
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "attack-block 5", desc: "deal [DAM5] damage and block", effect: attack_block(5, 5)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 2)}
                ], ["randomize"]),
                () => new Enemy("Louse", 35, [
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 2)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
                ], ["randomize"]),
                () => new Enemy("Spike Slime", 45, [
                    {intent: "attack-nerf 9", desc: "deal [DAM9] damage and generate Status cards", effect: attack_status(9, "Slimed", 1)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 1)}
                ]),
                () => new Enemy("Gremlin", 25, [
                    {intent: "attack-nerf 9", desc: "deal [DAM9] damage and apply a negative effect", effect: attack_apply(9, "Weak", 1)}
                ])
            ];
            let possibleElites = [
                () => new Enemy("Gremlin Nob", 85, [
                    {intent: "buffing +", desc: "gain a <b>powerful buff</b>", effect: buff("Enrage", 2)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and apply a negative effect", effect: attack_apply(6, "Vulnerable", 2)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)}
                ], ["no-repeat"]),
                () => new Enemy("Lagavulin", 110, [
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "blocking", desc: "block", effect: block(8)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: multi_apply([["Minus Strength", 1], ["Minus Dexterity", 1]])}
                ])
            ];
            let possibleBosses = [
                () => new Enemy("Slime Boss", 140, [
                    {intent: "meganerf", desc: "generate <b>many Status cards</b>", effect: status("Slimed", 3)},
                    {intent: "unknown", desc: "prepare for a strong attack", effect: function(me){}},
                    {intent: "attacking 25", desc: "deal [DAM25] damage", effect: attack(23)}
                ])
            ];
            let possibleEnemies_act2 = [
                () => new Enemy("Spheric Guardian", 60, [
                    {intent: "block-buff +", desc: "gain <b>multiple buffs</b>", effect: multi_buff([["Barricade", 1], ["Block", 25], ["Artifact", 3]])},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(7, "Frail", 5)},
                    {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 7)}
                ], ["no-repeat"]),
                () => new Enemy("The Chosen", 95, [
                    {intent: "attacking 7", desc: "deal [DAM10] damage", effect: attack(7)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: apply("Hex", 1)},
                    {intent: "attack-nerf 7", desc: "deal [DAM10] damage and apply a negative effect", effect: attack_apply(7, "Vulnerable", 2)},
                    {intent: "attacking 7", desc: "deal [DAM10] damage", effect: attack(7)},
                    {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                    {intent: "attacking 12", desc: "deal [DAM18] damage", effect: attack(12)},
                    {intent: "attack-nerf 7", desc: "deal [DAM10] damage and apply a negative effect", effect: attack_apply(10, "Vulnerable", 2)},
                    {intent: "attacking 7", desc: "deal [DAM10] damage", effect: attack(7)},
                    {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                    {intent: "attacking 12", desc: "deal [DAM18] damage", effect: attack(12)}
                ]),
                () => new Enemy("Shelled Parasite", 70, [
                    {intent: "attack-block 8", desc: "deal [DAM8] damage and block", effect: attack_block(8, 10)},
                    {intent: "attack-block 8", desc: "deal [DAM8] damage and block", effect: attack_block(8, 10)},
                    {intent: "attack-nerf 12", desc: "deal [DAM12] damage and apply a negative effect", effect: attack_apply(12, "Frail", 2)}
                ])
            ];
            let possibleElites_act2 = [
                () => new Enemy("Book of Stabbing", 160, [
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-buff 8", desc: "deal [DAM8] damage and gain a buff", effect: attack_buff(8, "Strength", 4)},
                    {intent: "attack-buff 8", desc: "deal [DAM8] damage and gain a buff", effect: attack_buff(8, "Strength", 4)}
                ]),
                () => new Enemy("Gremlin Leader", 150, [
                    {intent: "buffing", desc: "buff ALL enemies", effect: all_buff("Strength", 3)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "unknown", desc: "summon allies", effect: function(me){
                        let gremlins = [
                            () => new Enemy("Fat Gremlin", 15, [{intent: "attack-nerf 3", desc: "deal [DAM3] damage and apply a negative effect", effect: attack_apply(3, "Weak", 1)}]),
                            () => new Enemy("Mad Gremlin", 20, [{intent: "attack 4", desc: "deal [DAM4] damage", effect: attack(4)}]),
                            () => new Enemy("Shield Gremlin", 15, [{intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}, {intent: "blocking", desc: "shield a random enemy", effect: block_random(7)}]),
                            () => new Enemy("Sneaky Gremlin", 10, [{intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}]),
                            () => new Enemy("Wizard Gremlin", 25, [{intent: "unknown", desc: "charge a powerful attack", effect: function(me){}}, {intent: "unknown", desc: "charge a powerful attack", effect: function(me){}}, {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)}])
                        ];
                        enemies.push(choice(gremlins)()); enemies.push(choice(gremlins)());
                    }}
                ], ["randomize"])
            ];
            let possibleBosses_act2 = [
                () => new Enemy("The Champ", 420, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 2)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(15, "Metallicize", 3)},
                    {intent: "meganerf", desc: "apply a <b>many negative effects</b>", effect: multi_apply([["Vulnerable", 3], ["Weak", 2], ["Frail", 2]])},
                    {intent: "attacking 8", desc: "deal [DAM8] damage and apply a negative effect", effect: attack(8)}
                ], ["randomize"])
            ];
            let possibleEnemies_act3 = [
                () => new Enemy("Huge Jaw Worm", 70, [
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(8, "Strength", 2)},
                    {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(8, "Strength", 2)},
                    {intent: "attack-block 6", desc: "deal [DAM6] damage and block", effect: attack_block(6, 6)}
                ]),
                () => new Enemy("Spiker", 50, [
                    {intent: "unknown", desc: "summon friends", effect: function(me){
                        enemies.push(new Enemy("Exploder", 30, [
                            {intent: "unknown 6", desc: "deal [DAM6] damage and get ready to explode", effect: attack(6)},
                            {intent: "unknown 6", desc: "deal [DAM6] damage and get ready to explode", effect: attack(6)},
                            {intent: "unknown 20", desc: "deal [DAM20] damage and die", effect: function(me){me.dealDamage(20);me.hp=0}}
                        ]));
                        enemies.push(new Enemy("Repulsor", 30, [
                            {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
                        ]));
                    }},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 3)}
                ], ["no-repeat"]),
                () => new Enemy("Orb Walker", 90, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 3)},
                    {intent: "attack-nerf 10", desc: "deal [DAM10] damage and generate Status cards", effect: attack_status(10, "Burn", 1)}
                ], ["no-repeat"])
            ];
            let possibleElites_act3 = [
                () => new Enemy("Nemesis", 185, [
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Burn", 2)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)}
                ], ["randomize"]),
                () => new Enemy("Giant Head", 320, [
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attack-buff 21", desc: "deal [DAM21] damage and gain a buff", effect: attack_buff(21, "Strength", 3)}
                ], ["no-repeat"])
            ];
            let possibleBosses_act3 = [
                () => new Enemy("Time Eater", 500, [
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "block-nerf", desc: "block and apply negative effects", effect: block_multinerf(18, [["Vulnerable", 2], ["Weak", 1]])},
                    {intent: "attack-nerf 18", desc: "deal [DAM18] damage and apply a negative effect", effect: attack_apply(18, "Draw Reduction", 2)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-nerf 18", desc: "deal [DAM18] damage and apply a negative effect", effect: attack_apply(18, "Draw Reduction", 2)}
                ], ["randomize"])
            ];
            
            let enemies = [choice(possibleEnemies.slice(0))()];
            let eliteBattle = false;
            let bossBattle = false;
            let target = enemies[0];
            
            function updateStatLine() {
                let statusElemB4 = getId("statusLineB4");
                let deckNumber = getId("deckSize");
                let statusElem = getId("statusLine");
                statusElemB4.innerHTML=(hp<=0.25*maxHp ? "<span style='color: red'>HP: "+hp+"/"+maxHp+"</span>" : "HP: "+hp+"/"+maxHp);
                statusElemB4.innerHTML+=" | "+gold+" gold&nbsp;&nbsp;&nbsp;";
                deckNumber.innerHTML=deck.length;
                statusElem.innerHTML="&nbsp;&nbsp;&nbsp;<span id='relics'><b>Relics: </b></span>";
                for(let relic of relics) {
                    let relicElem = document.createElement("span");
                    relicElem.setAttribute("class", "tt");
                    relicElem.innerHTML = relic.name+", ";
                    let relicTooltip = document.createElement("span");
                    relicTooltip.setAttribute("class", "txt");
                    relicTooltip.innerHTML = relic.desc;
                    relicElem.appendChild(relicTooltip);
                    getId("relics").appendChild(relicElem);
                }
                statusElem.innerHTML+= "<span id='potions'><b>Potions: </b></span>";
                for(let potion of potions) {
                    let potionElem = document.createElement("button");
                    potionElem.setAttribute("class", "tt");
                    potionElem.setAttribute("onclick", `let x = function(tgt) { ${potion.effect} }; x(target); potions.splice(${potions.indexOf(potion)}, 1); updateHtml();`);
                    potionElem.innerHTML = potion.name+" Potion";
                    let potionTooltip = document.createElement("span");
                    potionTooltip.setAttribute("class", "txt");
                    potionTooltip.innerHTML = potion.desc;
                    potionElem.appendChild(potionTooltip);
                    getId("potions").appendChild(potionElem);
                }
                for(let i=0; i<(3-potions.length); i++) {
                    let potionElem = document.createElement("button");
                    potionElem.setAttribute("class", "nonbutton");
                    potionElem.innerHTML = "Empty Slot";
                    getId("potions").appendChild(potionElem);
                }
                let min = Math.floor((Date.now()-startTime)/60000).toString();
                let sec = Math.floor((Date.now()-startTime)%60000/1000).toString();
                let sec_100ths = Math.floor((Date.now()-startTime)%1000/10).toString();
                //statusElem.innerHTML += "&nbsp;&nbsp;&nbsp;"+min+":"+sec.padStart(2, "0")+"."+sec_100ths.padStart(2, "0"); // x:xx.xx
                statusElem.innerHTML += "&nbsp;&nbsp;&nbsp;"+min+":"+sec.padStart(2, "0"); // x:xx
                getId("drawPile").innerHTML = "View Draw Pile | <span style='color:white'>"+drawPile.length+"</span>";
                getId("discardPile").innerHTML = "View Discard Pile | <span style='color:white'>"+discardPile.length+"</span>";
                getId("exhaustPile").innerHTML = "View Exhaust Pile | <span style='color:white'>"+exhaustPile.length+"</span>";
            }
            function updateHtml() {
                updateStatLine();
                if(hasBuff("Strength") > 0 && hasBuff("Minus Strength") > 0) {
                    if(hasBuff("Strength") >= hasBuff("Minus Strength")) {
                        loseBuff("Strength", hasBuff("Minus Strength"));
                        loseBuff("Minus Strength");
                    } else {
                        loseBuff("Minus Strength", hasBuff("Strength"));
                        loseBuff("Strength");
                    }
                }
                if(hasBuff("Dexterity") > 0 && hasBuff("Minus Dexterity") > 0) {
                    if(hasBuff("Dexterity") >= hasBuff("Minus Dexterity")) {
                        loseBuff("Dexterity", hasBuff("Minus Dexterity"));
                        loseBuff("Minus Dexterity");
                    } else {
                        loseBuff("Minus Dexterity", hasBuff("Dexterity"));
                        loseBuff("Dexterity");
                    }
                }
                let energyElem = getId("energy");
                energyElem.innerHTML = energy+"/"+maxEnergy+"<span class='txt'>Energy is used to play cards from your hand.</span>";
                if(energy == 0) {energyElem.style.background = "#884";}
                else {energyElem.style.background = "yellow";}
                
                let playerElem = getId("player");
                playerElem.innerHTML = "Your Hand: "+
                    (buffs.length ? (" [ "+buffs.map(
                        x => "<span class='tt'>"+x.name+" "+x.amt+"<span class='txt'>"+buffDesc[x.name]
                        .replace("[AMT]", x.amt)
                        .replace("[s]", (x.amt==1 ? "" : "s"))
                        .replace("[es]", (x.amt==1 ? "" : "es"))+"</span></span>"
                    ).join(", ")+" ]") : "");
                
                let handElem = getId("hand");
                handElem.innerHTML = "";
                for(let c of hand) {
                    let cardElem = document.createElement("button");
                    let playcard = async () => { await c.play(); }
                    cardElem.onclick = playcard;
                    if(c.flags.includes("unplayable") || energy < c.cost) {cardElem.setAttribute("class", "tt unplayable "+c.type);}
                    else {cardElem.setAttribute("class", "tt "+c.type);}
                    cardElem.innerHTML = c.name;
                    let cardTooltip = document.createElement("span");
                    cardTooltip.setAttribute("class", "txt");
                    
                    let newDesc = c.desc.replace("[BLOCK]", "[DAM"+hasBuff("Block")+"]")
                    .replace("[BLOOD4BLOOD]", 4 - stats.timesLostHp)
                    .replace("[HEAVYBLADE]", "[DAM"+(14+hasBuff("Strength")*2)+"]")
                    .replace("[HEAVYBLADE+]", "[DAM"+(14+hasBuff("Strength")*4)+"]")
                    .replace("[RAMPAGE]", "[DAM"+(8+hasBuff("Rampage"))+"]")
                    .replace("[SHIV]", "[DAM"+(4+hasBuff("Accuracy"))+"]")
                    .replace("[SHIV+]", "[DAM"+(6+hasBuff("Accuracy"))+"]");
                    for(let i=1; i<300; i++) {
                        let newI = i;
                        if(target.hasBuff("Vulnerable")) {newI = Math.round(newI*1.5);}
                        if(hasBuff("Weak")) {newI = Math.round(newI*0.75);}
                        newI += hasBuff("Strength");
                        newI -= hasBuff("Minus Strength");
                        if(newI > i) {newI = "<span style='color:lime'>"+newI+"</span>";}
                        else if(newI < i) {newI = "<span style='color:orangered'>"+newI+"</span>";}
                        let blockI = i;
                        if(hasBuff("Frail")) {blockI = Math.round(blockI*0.75);}
                        blockI += hasBuff("Dexterity");
                        blockI -= hasBuff("Minus Dexterity");
                        if(blockI > i) {blockI = "<span style='color:lime'>"+blockI+"</span>";}
                        else if(blockI < i) {blockI = "<span style='color:orangered'>"+blockI+"</span>";}
                        
                        newDesc = newDesc.replace("[DAM"+i+"]", newI).replace("[BLK"+i+"]", blockI);
                        newDesc = newDesc.replace("[DAM"+i+"]", newI).replace("[BLK"+i+"]", blockI);
                    }
                    cardTooltip.innerHTML = addCircle(c.cost.toString())+" "+c.type+"<br/>"+newDesc;
                    
                    cardElem.appendChild(cardTooltip);
                    handElem.appendChild(cardElem);
                }
                
                let enemiesElem = getId("enemies");
                enemiesElem.innerHTML = "";
                for(let eIndex in enemies) {
                    let e = enemies[eIndex];
                    if(e.hasBuff("Strength") > 0 && e.hasBuff("Minus Strength") > 0) {
                        if(e.hasBuff("Strength") >= e.hasBuff("Minus Strength")) {
                            e.loseBuff("Strength", e.hasBuff("Minus Strength"));
                            e.loseBuff("Minus Strength");
                        } else {
                            e.loseBuff("Minus Strength", e.hasBuff("Strength"));
                            e.loseBuff("Strength");
                        }
                    }
                    let enemyElem = document.createElement("span");
                    enemyElem.setAttribute("class", "tt");
                    let enemyButton = document.createElement("button");
                    enemyButton.setAttribute("onclick", `target = enemies[${eIndex}]; updateHtml();`);
                    let intentType = e.intent.intent.split(" ")[0];
                    let intentNumber = "";
                    if(e.intent.intent.split(" ")[1]) {
                        if(parseInt(e.intent.intent.split(" ")[1])) {
                            intentNumber = parseInt(e.intent.intent.split(" ")[1]);
                            if(hasBuff("Vulnerable") > 0) {intentNumber = Math.round(intentNumber*1.5);}
                            if(e.hasBuff("Weak") > 0) {intentNumber = Math.round(intentNumber*0.75);}
                            intentNumber += e.hasBuff("Strength");
                            intentNumber -= e.hasBuff("Minus Strength");
                            if(intentNumber >= 20) {
                                intentType = "bigattack";
                            }
                        } else {
                            intentNumber = e.intent.intent.split(" ")[1];
                        }
                    }
                    if(e.number == target.number) {
                        enemyButton.setAttribute("class", intentType);
                    } else {
                        enemyButton.setAttribute("class", intentType+" nonbutton");
                    }
                    enemyButton.innerHTML = "<span style='color:white'>"+intentNumber+"</span>&nbsp;"+e.name;
                    enemyElem.appendChild(enemyButton);
                    if(e.hasBuff("Block") > 0) {
                        enemyElem.innerHTML += " HP: "+e.hp+" (<img src='StS/intent-block.png'>"+e.hasBuff("Block")+") / "+e.maxHp;
                    } else {
                        enemyElem.innerHTML += " HP: "+e.hp+" / "+e.maxHp;
                    }
                    let enemyTooltip = document.createElement("span");
                    enemyTooltip.setAttribute("class", "txt");
                    let newDesc = e.intent.desc;
                    for(let i=1; i<300; i++) {
                        let newI = i;
                        if(hasBuff("Vulnerable") > 1) {newI = Math.round(newI*1.5);}
                        if(e.hasBuff("Weak") > 0) {newI = Math.round(newI*0.75);}
                        newI += e.hasBuff("Strength");
                        newI -= e.hasBuff("Minus Strength");
                        if(newI > i) {newI = "<span style='color:lime'>"+newI+"</span>";}
                        else if(newI < i) {newI = "<span style='color:orangered'>"+newI+"</span>";}
                        newDesc = newDesc.replace("[DAM"+i+"]", newI);
                    }
                    enemyTooltip.innerHTML = e.name+" intends to "+newDesc+".";
                    enemyTooltip.innerHTML += e.buffs.length ? ("<br/>" + e.buffs.map(x => x.name+" "+x.amt+" ("+buffDesc[x.name].replace("[AMT]", x.amt).replace("[s]", (x.amt==1 ? "" : "s")).replace("[es]", (x.amt==1 ? "" : "es"))+")").join("<br/>")) : "";
                    enemyElem.appendChild(enemyTooltip);
                    enemiesElem.appendChild(enemyElem);
                    enemiesElem.appendChild(document.createElement("br"));
                }
                if(enemies.filter(x => x.hp <= 0).length > 0) {
                    enemies = enemies.filter(x => x.hp > 0);
                    updateHtml();
                }
                if(!enemies.includes(target) || !target) {target = enemies[0]; updateHtml();}
                if(enemies.length == 0) {
                    getId("rewardsScreen").style.display = "block";
                    getId("goldReward").style.display = "block";
                    getId("cardReward").style.display = "block";
                    getId("gameScreen").style.display = "none";
                    let goldAmt = Math.round(Math.random()*10)+25;
                    getId("goldReward").innerHTML = goldAmt+" gold";
                    getId("goldReward").setAttribute("onclick", `gold += ${goldAmt}; updateStatLine(); getId('goldReward').style.display = 'none';`);
                    if(Math.random() < 0.5 && potions.length < 3) { // set to 1 (always drop) for testing
                        getId("potionReward").style.display = "block";
                        let potionDrop = choice(potionPool);
                        getId("potionReward").innerHTML = potionDrop.name+" Potion";
                        getId("potionReward").setAttribute("onclick", `potions.push({name: "${potionDrop.name}", desc: "${potionDrop.desc}", effect: "${potionDrop.effect}"}); updateStatLine(); getId('potionReward').style.display = 'none';`);
                    } else if(potions.length >= 3) {
                        getId("potionReward").style.display = "block";
                        getId("potionReward").innerHTML = "Potion slots full!";
                        getId("potionReward").removeAttribute("onclick");
                    } else {
                        getId("potionReward").style.display = "none";
                    }
                    if(eliteBattle == true) {
                        getId("relicReward").style.display = "block";
                        let newRelic = choice(relicPool)();
                        getId("relicReward").innerHTML = newRelic.name+"<span class='txt'>"+newRelic.desc+"</span>";
                        getId("relicReward").setAttribute("onclick", `let r = new Relic('${newRelic.name}', '${newRelic.desc}', '${newRelic.trigger}', ${newRelic.use}); relics.push(r); if(r.trigger=='on_pickup') {r.effect();} updateStatLine(); getId('relicReward').style.display = 'none';`);
                    } else {
                        getId("relicReward").style.display = "none";
                    }
                    if(bossBattle == true) {
                        getId("bossRelicReward").style.display = "block";
                        getId("bossRelicReward").innerHTML = "Choose a Relic";
                        getId("bossRelicReward").setAttribute("onclick", "addBossRelic('random'); getId('bossRelicReward').style.display = 'none';");
                    } else {
                        getId("bossRelicReward").style.display = "none";
                    }
                }
                if(hp <= 0) {
                    alert("You died! D:");
                    getId("gameScreen").style.display = "none";
                }
                let x = document.getElementsByClassName("txt");
                for (t of x) {
                    t.style.left = (mousex+10) + "px";
                    t.style.top = (mousey+10+window.pageYOffset) + "px";
                }
            }
            
            function addShivs(num=1) {
                for(let i=0; i<num; i++) {
                    hand.push(new Card("Shiv", 0, "Attack", "Deal [SHIV] damage. Exhaust.", function(e){dealDamage(e,4);}, ["exhausted"]));
                }
            }
            function addShivPluses(num=1) {
                for(let i=0; i<num; i++) {
                    hand.push(new Card("Shiv+", 0, "Attack", "Deal [SHIV+] damage. Exhaust.", function(e){dealDamage(e,6);}, ["exhausted"]));
                }
            }
            
            function drawCard(num=1) {
                if(hasBuff("No Draw") > 0) {num=0;}
                for(let x=0; x<num; x++) {
                    if(drawPile.length <= 0) {
                        drawPile = shuffle(discardPile);
                        discardPile = [];
                    }
                    if(drawPile.length > 0) {
                        let toDraw = drawPile.pop(0);
                        hand.push(toDraw);
                        if(toDraw.type == "Status") {
                            drawCard(hasBuff("Evolve"));
                            for(let e of enemies) {
                                dealDamage(e, hasBuff("Fire Breathing"));
                            }
                        }
                    } else {
                        alert("Uh-oh, nothing to draw...");
                    }
                }
            }
            
            function startTurn() {
                log("Player turn ========", "#666");
                if(hasBuff("Draw Reduction") > 0) {
                    drawCard(4); loseBuff("Draw Reduction", 1);
                } else {
                    drawCard(5);
                }
                for(let relic of relics) {
                    if(relic.name == "Ice Cream") {
                        gainBuff("Next Turn Energy", energy);
                    }
                }
                energy = maxEnergy + hasBuff("Energize") + hasBuff("Next Turn Energy");
                loseBuff("Next Turn Energy");
                if(stats.attacksThisTurn == 0) {
                    for(let relic of relics) {if(relic.trigger == "no_attacks") {relic.effect();}}
                }
                if(stats.rested == true) {
                    stats.rested = false;
                    for(let relic of relics) {if(relic.trigger == "rest") {relic.effect();}}
                }
                for(let r of relics) {if(r.trigger == "turn_start") {r.effect();}}
                stats.attacksThisTurn = 0;
                stats.skillsThisTurn = 0;
                if(hasBuff("Barricade")==0 && hasBuff("Blur")==0){loseBuff("Block");}
                loseBuff("Blur", 1);
                if(hasBuff("Metallicize")>0){gainBuff("Block", hasBuff("Metallicize"));}
                if(hasBuff("Brutality")>0){hp -= 1; drawCard(hasBuff("Brutality"));}
                updateHtml();
            }
            
            function endTurn() {
                log("Enemy turn =========", "#666");
                for(let c of hand) {
                    if(c.flags.includes("ethereal")) {exhaustPile.push(c);}
                    else {discardPile.push(c);}
                    if(c.flags.includes("burning")) {hp -= 1;}
                }
                for(let r of relics) {if(r.trigger == "turn_end") {r.effect();}}
                hand = [];
                loseBuff("Vulnerable", 1);
                loseBuff("Weak", 1);
                loseBuff("Frail", 1);
                loseBuff("No Draw", 1);
                hp = Math.min(maxHp, hp + hasBuff("Regen"));
                loseBuff("Regen", 1);
                loseBuff("Rage");
                gainBuff("Strength", hasBuff("Ritual"));
                loseBuff("Strength", hasBuff("Strength Down"));
                loseBuff("Strength Down");
                loseBuff("Dexterity", hasBuff("Dexterity Down"));
                loseBuff("Dexterity Down");
                if(hasBuff("Poison")>0) {hp -= hasBuff("Poison"); loseBuff("Poison", 1);}
                if(hasBuff("Combust") > 0) {
                    hp -= 1;
                    for(let e of enemies) {dealDamage(e, hasBuff("Combust"));}
                }
                updateHtml();
                for(let e of enemies) {
                    if(e.hasBuff("Barricade")==0){e.loseBuff("Block");}
                    if(e.hasBuff("Metallicize")>0){e.gainBuff("Block", e.hasBuff("Metallicize"));}
                    e.attack();
                    e.loseBuff("Vulnerable", 1);
                    e.loseBuff("Weak", 1);
                    e.hp = Math.min(e.maxHp, e.hp + e.hasBuff("Regen"));
                    e.loseBuff("Regen", 1);
                    e.gainBuff("Strength", e.hasBuff("Ritual"));
                    e.loseBuff("Strength", e.hasBuff("Strength Down"));
                    e.loseBuff("Strength Down");
                    e.loseBuff("Dexterity", e.hasBuff("Dexterity Down"));
                    e.loseBuff("Dexterity Down");
                    if(e.hasBuff("Poison")>0) {e.hp -= e.hasBuff("Poison"); e.loseBuff("Poison", 1);}
                }
                startTurn();
            }
            
            for(let r of relics) {if(r.trigger == "combat_start") {r.effect();}}
            for(let card of drawPile) {
                if(card.flags.includes("innate")) {
                    drawPile.splice(drawPile.indexOf(card), 1);
                    hand.push(card);
                }
            }
            getId("combatLog").innerHTML = "";
            startTurn();
            window.setInterval(updateStatLine, 1000);
        </script>
    </body>
</html>
