<html id="html">
    <head>
        <title>Google Docs</title>
        <link rel="shortcut icon" href="https://ssl.gstatic.com/docs/documents/images/kix-favicon7.ico"> <!-- Google Docs's icon -->
        <style>
            html {
                color: white;
                background: #222;
                font-family: monospace;
            }
            button {
                border: 2px solid lime;
                margin: 1px;
                cursor: pointer;
                color: lime;
                background: black;
                font-family: monospace;
                transition: 0.3s ease;
                border-radius: 3px;
            }
            .nonbutton {border: 2px solid green; color: green;}
            .Attack {border: 2px solid red; color: red;}
            .Skill {border: 2px solid skyblue; color: skyblue;}
            .Power {border: 2px solid yellow; color: yellow;}
            .Status {border: 2px solid lightgreen; color: lightgreen;}
            .unplayable {border: 2px solid #555; color: #555;}
            button:hover:not(.unplayable) {background-color: #444;}
            button:hover > span {font-size: 13px;}
            table {width: 100%;}
            .tt {user-select: none;}
            .txt {
                position: absolute;
                background: #666;
                color: black;
                display: none;
                text-align: left;
                border-radius: 5px;
                margin-left: 10px;
                padding: 5px;
            }
            .tt:hover > .txt {display: inline;}
            #energy, #player {display: inline;}
            #energy {
                border: 2px solid black;
                border-radius: 20px;
                padding: 3px;
                color: black;
                background: yellow;
            }
            #playerTd {width: 750px;}
            #rewardsScreen {text-align: center; width: 100%;}
            #rewardsScreen > button {text-align: center; width: 100%; border: none;}
            #mapScreen {margin-left: 42%; width: 58%;}
            .attacking::before { content: url(StS/intent-attack.png); }
            .bigattack::before { content: url(StS/intent-bigattack.png); }
            .blocking::before { content: url(StS/intent-block.png); }
            .buffing::before { content: url(StS/intent-buff.png); }
            .nerfing::before { content: url(StS/intent-nerf.png); }
            .meganerf::before { content: url(StS/intent-meganerf.png); }
            .unknown::before { content: url(StS/intent-unknown.png); }
            .attack-block::before { content: url(StS/intent-attackblock.png); }
            .block-buff::before { content: url(StS/intent-blockbuff.png); }
            .attack-nerf::before { content: url(StS/intent-attacknerf.png); }
            .attack-buff::before { content: url(StS/intent-attackbuff.png); }
            .block-nerf::before { content: url(StS/intent-blocknerf.png); }
            #cardModal, #bossModal, #selectionModal {
                position: fixed;
                z-index: 1;
                left: 0;
                top: 0;
                width: 100%;
                height: 100%;
                overflow: auto;
                background-color: rgba(0,0,0,0.7);
            }
            #cardModalContent, #bossModalContent, #selectionModalContent {
                background-color: #555;
                margin: 15% auto;
                padding: 20px;
                width: 80%;
            }
            #h1 {
                text-align: center;
                font-size: 30px;
                width: 80%;
                animation: grow 0.8s infinite;
                margin: 0px 0px 30px 140px;
            }
            #startButton, #rulesButton, #keyButton {
                text-align: center;
                width: 100%;
                border: none;
                font-size: 16px;
                transition: 0.2s ease-in-out;
            }
            #startButton:hover, #rulesButton:hover, #keyButton:hover {
                font-size: 21px;
                color: black;
                background: lime;
                font-weight: bold;
            }
            @keyframes grow {
                0%    { transform: scale(1);    }
                12.5% { transform: scale(1.08); }
                25%   { transform: scale(1.14); }
                37.5% { transform: scale(1.18); }
                50%   { transform: scale(1.20); }
                62.5% { transform: scale(1.18); }
                75%   { transform: scale(1.14); }
                87.5% { transform: scale(1.08); }
                100%  { transform: scale(1);    }
            }
            @keyframes boing {
                0%    { transform: translate(0px, 0px);   }
                12.5% { transform: translate(0px,-8px);   }
                25%   { transform: translate(0px, -14px); }
                37.5% { transform: translate(0px, -18px); }
                50%   { transform: translate(0px, -20px); }
                62.5% { transform: translate(0px, -18px); }
                75%   { transform: translate(0px, -14px); }
                87.5% { transform: translate(0px, -8px);  }
                100%  { transform: translate(0px, 0px);   }
            }
            @keyframes wiggle {
                0%  { transform: rotate(10deg);  }
                10% { transform: rotate(2deg);   }
                20% { transform: rotate(-4deg);  }
                30% { transform: rotate(-8deg);  }
                40% { transform: rotate(-10deg); }
                50% { transform: rotate(-10deg); }
                60% { transform: rotate(-2deg);  }
                70% { transform: rotate(4deg);   }
                80% { transform: rotate(8deg);   }
                90% { transform: rotate(10deg);  }
                100%{ transform: rotate(10deg);  }
            }
        </style>
    </head>
    <body>
        <div id="selectionModal" style="display: none;">
            <div id="selectionModalContent"></div>
        </div>
        <div id="cardModal" style="display: none;">
            <div id="cardModalContent">
                <p>Choose a card to add to your deck:</p>
                <button id="modalCard1" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(0);"></button>
                <button id="modalCard2" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(1);"></button>
                <button id="modalCard3" class="tt" onclick="getId('cardModal').style.display = 'none'; finishAddCard(2);"></button>
                <button id="modalSkipCard" class="Skill" onclick="getId('cardModal').style.display = 'none'; finishAddCard(-1);">Skip</button>
            </div>
        </div>
        <div id="bossModal" style="display: none;">
            <div id="bossModalContent">
                <p>Choose a Rare Relic to obtain:</p>
                <button id="modalRelic1" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(0);"></button>
                <button id="modalRelic2" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(1);"></button>
                <button id="modalRelic3" class="tt" onclick="getId('bossModal').style.display = 'none'; finishAddRelic(2);"></button>
            </div>
        </div>
        <span id="damageNumber0" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber1" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber2" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber3" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber4" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber5" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber6" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber7" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber8" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="damageNumber9" style="position:absolute; opacity:0; color:yellow; pointer-events: none;"></span>
        <span id="statusContainer" style="display: none;">
            <span id="statusLineB4"></span>
            <button onclick="let d=deck.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+'x '+x[0]).join('\n');let c=[new ClipboardItem({'text/plain':new Blob([T],{type:'text/plain'})})];navigator.clipboard.write(c);alert(T+'\nDecklist copied to clipboard.');">View <span style="text-decoration:underline">D</span>eck | <span style="color:white" id="deckSize">10</span></button>
            <span id="statusLine"></span>
        </span>
        <br /><br />
        <div id="introScreen" style="width: 100%;">
            <h1 id="h1">Slay The Spire <span class="Power" style="font-size:24px;border:none;">For Web</span></h1>
            <button id="startButton" onclick="getId('introScreen').style.display = 'none'; getId('statusContainer').style.display = 'block'; showMap(); beforeTime = Date.now(); currentTimer = 0;">Play</button>
            <button id="rulesButton" onclick="getId('rulesScreen').style.display = 'block'; getId('keyScreen').style.display = 'none';">Instructions</button>
            <button id="keyButton" onclick="getId('keyScreen').style.display = 'block'; getId('rulesScreen').style.display = 'none';">Keybinds</button>
            <pre id="rulesScreen" style="display: none;">
When you begin you will be on the Map. Click a highlighted node to travel there.
In combat, your cards will be shown on the left and the enemies will be on the right.
Click a card to play it. Depending on the card, it might target the selected enemy, all enemies, or yourself.
You should watch the enemies' intents and play cards accordingly.

A rest node is extremely useful, allowing you to heal or upgrade a card.
A shop sells cards and relics, gather gold from enemies to buy them.
Elites are stronger enemies that drop rare cards and a helpful Relic on defeat.

One last tip: Many things can be hovered to see their description.
            </pre>
            <pre id="keyScreen" style="display: none;">
Number          select from dialog / buy cards / play cards / travel
D               view and copy deck
T               pause/resume timer
E               end turn
P               draw pile
I               discard pile
X               exhaust pile
, . /           use potion
Space           claim reward
C               continue (from shop, combat, rest)
R/S             rest/smith at rest sites
            </pre>
        </div>
        <table id="gameScreen" style="display: none;">
            <tr>
                <td id="playerTd">
                    <div id="player"></div>
                    <br />
                    <span id="energy" class="tt"></span>&nbsp;&nbsp;&nbsp;<span id="hand"></span>
                    <br /><br />
                    <button id="discardPile" onclick="alert(discardPile.map(x => x.name).join(', '))">View D<span style="text-decoration:underline">i</span>scard Pile</button>
                    <button id="drawPile" onclick="alert(shuffle(drawPile.map(x => x.name)).join(', '))">View Draw <span style="text-decoration:underline">P</span>ile</button>
                    <button id="exhaustPile" onclick="alert(exhaustPile.map(x => x.name).join(', '))">View E<span style="text-decoration:underline">x</span>haust Pile</button>
                    | <button onclick="endTurn()"><span style="text-decoration:underline">E</span>nd Turn</button>
                </td>
                <td id="enemiesTd">
                    <div id="enemies"></div>
                </td>
            </tr>
        </table>
        <div id="rewardsScreen" style="display: none;">
            You won! Rewards:<br />
            <button id="goldReward"></button>
            <button id="cardReward" onclick="getId('cardReward').style.display = 'none'; addCard('random');">Add a card to your deck</button>
            <button id="potionReward"></button>
            <button id="relicReward" class="tt"></button>
            <button id="bossRelicReward" class="tt"></button>
            <button id="closeRewards" onclick="showMap();"><span style='text-decoration:underline'>C</span>ontinue</button>
        </div>
        <table id="mapScreen" style="display: none;"></table>
        <div id="restScreen" style="display: none;">
            <span>You are at a Rest Site. Choose an option below.</span>
            <br />
            <button onclick="hp = Math.min(maxHp, Math.round(hp+0.3*maxHp)); stats.rested = true; showMap();" class="tt"><span style='text-decoration:underline'>R</span>est<span class="txt">Heal 30% of your Max HP.</span></button>
            <button onclick="upgradeDialog();" class="tt"><span style='text-decoration:underline'>S</span>mith<span class="txt">Upgrade a card in your deck.</span></button>
            <div id="upgradeDialog" style="display: none;">
                <p id="cardDesc"></p>
                <button onclick="upgradeCard(cardToUpgrade); getId('upgradeDialog').style.display = 'none'; showMap();"><span style='text-decoration:underline'>C</span>onfirm</button>
            </div>
        </div>
        <table id="merchantScreen" style="display: none;">
        </table>
        <script>
            function shuffle(array) {
                let currentIndex = array.length, randomIndex;
                while(currentIndex != 0) {
                    randomIndex = Math.floor(Math.random() * currentIndex);
                    currentIndex--;
                    [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
                }
                return array;
            }
            let getId = x => document.getElementById(x);
            let choice = x => x[Math.floor(Math.random()*x.length)];
            let resolvePromise;
            let modalNames = [];
            async function showCardChoiceModal(displayCards, prompt) {
                getId("selectionModalContent").innerHTML = prompt + "<br/>";
                modalNames = [];
                for(let c of displayCards) {
                    modalNames.push(c.name);
                    let cardButton = document.createElement("button");
                    cardButton.setAttribute("onclick", "resolvePromise('"+c.name+"');");
                    cardButton.setAttribute("class", c.type+" tt");
                    cardButton.innerHTML = c.name+"<span class='txt'>"+addCircle(c.cost.toString())+" "+c.type+"<br/>"+unformat(c.desc)+"</span>";
                    getId("selectionModalContent").appendChild(cardButton);
                }
                getId("selectionModal").style.display = "block";
                let promise = new Promise((resolve, reject) => {
                    resolvePromise = resolve;
                });
                let chosenCard;
                await promise.then((result) => {
                    getId("selectionModal").style.display = "none";
                    chosenCard = displayCards[displayCards.map(x=>x.name).indexOf(result)];
                });
                return chosenCard;
            }
            async function choose(c, p) {
                if(c.length >= 1) {
                    let wooga = await showCardChoiceModal(c, p);
                    return wooga;
                } else {
                    return null;
                }
            }
            let mousex = 0;
            let mousey = 0;
            document.onmousemove = function(e) {
                let x = document.getElementsByClassName("txt");
                mousex = e.clientX;
                mousey = e.clientY;
                for (t of x) {
                    t.style.left = (mousex+10) + "px";
                    t.style.top = (mousey+10+window.pageYOffset) + "px";
                }
            }
            async function numberKey(n) {
                if(getId("cardModal").style.display != "none" && n<=2) {getId('cardModal').style.display='none'; finishAddCard(n);}
                else if(getId("cardModal").style.display != "none" && n==3) {getId('cardModal').style.display='none';finishAddCard(-1);}
                else if(getId("bossModal").style.display != "none" && n<=2) {getId('bossModal').style.display='none';finishAddRelic(n);}
                else if(getId("selectionModal").style.display != "none" && n<modalNames.length) { resolvePromise(modalNames[n]); }
                else if(getId("merchantScreen").style.display != "none" && n<offers.length) {
                    let offer = offers[n].offer;
                    let cost = offers[n].price;
                    if(gold >= cost) {
                        gold -= cost;
                        if(offers[n].index >= 100) {
                            let r = new Relic(offer.name, offer.desc, offer.trigger, offer.use);
                            relics.push(r);
                            if(r.trigger=='on_pickup') {r.effect();}
                            getId("relicElem_"+n).style.display = "none";
                            updateStatLine();
                            updateShopScreen();
                        } else {
                            deck.push(new Card(offer.name, offer.cost, offer.type, offer.desc, offer.use, offer.flags));
                            getId("cardElem_"+n).style.display = "none";
                            updateStatLine();
                            updateShopScreen();
                        }
                    }
                } else if(getId("gameScreen").style.display != "none") { await hand[n].play(); }
                else if(getId("mapScreen").style.display != "none" && n <= 2) { gotoMap(mapY + 1, mapX + n - 1); }
            }
            document.onkeypress = async function(e) {
                e = e || window.event;
                //alert("You just pressed "+e.keyCode);
                if(e.keyCode == 100) { // d
                    let d=deck.map(x=>x.name);let o={};for(let i of d){if(Object.keys(o).includes(i)){o[i]+=1;}else{o[i]=1;}}let t=[];for(let i of Object.keys(o).sort()){t.push([i,o[i]]);}let T=t.map(x=>x[1]+'x '+x[0]).join('\n');let c=[new ClipboardItem({'text/plain':new Blob([T],{type:'text/plain'})})];navigator.clipboard.write(c);alert(T+'\nDecklist copied to clipboard.');
                } else if(e.keyCode == 116) { // t
                    if(timerRunning){timerRunning=false;getId('timer').setAttribute('class','Attack');updateStatLine();}else{timerRunning=true;getId('timer').setAttribute('class','Skill');updateStatLine();}
                } else if(e.keyCode == 112 && getId("gameScreen").style.display != "none") { // p
                    alert(shuffle(drawPile.map(x=>x.name)).join(', '));
                } else if(e.keyCode == 105 && getId("gameScreen").style.display != "none") { // i
                    alert(discardPile.map(x=>x.name).join(', '));
                } else if(e.keyCode == 120 && getId("gameScreen").style.display != "none") { // x
                    alert(exhaustPile.map(x=>x.name).join(', '));
                } else if(e.keyCode == 101 && getId("gameScreen").style.display != "none") { // e
                    endTurn();
                // numbers
                } else if(e.keyCode == 49) {await numberKey(0);}
                else if(e.keyCode == 50) {await numberKey(1);}
                else if(e.keyCode == 51) {await numberKey(2);}
                else if(e.keyCode == 52) {await numberKey(3);}
                else if(e.keyCode == 53) {await numberKey(4);}
                else if(e.keyCode == 54) {await numberKey(5);}
                else if(e.keyCode == 55) {await numberKey(6);}
                else if(e.keyCode == 56) {await numberKey(7);}
                else if(e.keyCode == 57) {await numberKey(8);}
                else if(e.keyCode == 58) {await numberKey(9);}
                else if(e.keyCode == 32) { // space
                    if(getId("rewardsScreen").style.display != "none") {
                        if(getId("goldReward").style.display != "none") {
                            let func = getId("goldReward").getAttribute("onclick"); eval(func);
                        } else if(getId("cardReward").style.display != "none") {
                            let func = getId("cardReward").getAttribute("onclick"); eval(func);
                        } else if(getId("potionReward").style.display != "none") {
                            let func = getId("potionReward").getAttribute("onclick"); eval(func);
                        } else if(getId("relicReward").style.display != "none") {
                            let func = getId("relicReward").getAttribute("onclick"); eval(func);
                        } else if(getId("bossRelicReward").style.display != "none") {
                            let func = getId("bossRelicReward").getAttribute("onclick"); eval(func);
                        } else { showMap(); }
                    }
                } else if(e.keyCode == 99) { // c
                    if(getId("merchantScreen").style.display != "none" || getId("rewardsScreen").style.display != "none") {
                        showMap();
                    } else if(getId("upgradeDialog").style.display != "none") {
                        upgradeCard(cardToUpgrade); getId('upgradeDialog').style.display = 'none'; showMap();
                    }
                } else if(e.keyCode == 114) { // r
                    if(getId("restScreen").style.display != "none") {
                        hp = Math.min(maxHp, Math.round(hp+0.3*maxHp)); stats.rested = true; showMap();
                    }
                } else if(e.keyCode == 115) { // s
                    if(getId("restScreen").style.display != "none") {upgradeDialog();}
                } else if(e.keyCode == 44) { // ,
                    if(potions.length >= 1) {let x = eval("let tgt=target; "+potions[0].effect); potions.splice(0, 1); updateHtml();}
                } else if(e.keyCode == 46) { // .
                    if(potions.length >= 2) {let x = eval("let tgt=target; "+potions[1].effect); potions.splice(1, 1); updateHtml();}
                } else if(e.keyCode == 47) { // /
                    if(potions.length >= 3) {let x = eval("let tgt=target; "+potions[2].effect); potions.splice(2, 1); updateHtml();}
                }
            };
            function unformat(desc) {
                return desc.replace(" (Costs [BLOOD4BLOOD] energy)", "").replace("[HEAVYBLADE]", 14).replace("[HEAVYBLADE+]", 14).replace("[RAMPAGE]", 8).replace(" ([BLOCK] damage)", "").replace("[DAM", "").replace("[BLK", "").replace("[DAM", "").replace("[BLK", "").replace(" (Deals [FINISHER] damage)", "").replace(" (Deals [FINISHER+] damage)", "").replace("[SHIV]", 4).replace("[SHIV+]", 6).replace("]", "").replace("]", "");
            }
            function addCircle(char) {
                let circles = {"X": "ⓧ", "0": "⓪", "1": "①", "2": "②", "3": "③", "4": "④", "5": "⑤"};
                return "<b>"+circles[char]+"</b>";
                //return circles[char];
            }
            class Card {
                /*
                'effect' is a function that takes the current target, whether it is used or not.
                */
                constructor(name, cost, type, desc, use, flags=[]) {
                    this.name = name;
                    this.cost = cost;
                    this.type = type;
                    this.desc = desc;
                    this.use = use;
                    this.flags = flags;
                    this.number = Math.random();
                }
                async play() {
                    let played = false;
                    if(this.cost == "X") {
                        for(let x=0; x<energy; x++) {
                            this.use(target);
                        }
                        energy = 0;
                        played = true;
                    } else {
                        let newCost = this.cost;
                        if(this.flags.includes("blood4blood")) {
                            newCost = Math.max(0, 4-stats.timesLostHp);
                        }
                        if(energy >= newCost && !(this.flags.includes("unplayable"))) {
                            energy -= newCost;
                            if(!this.use) {alert("Uh oh! Seems like card [" + (this.name ? this.name : "unnamed") + "] has no `use` function");}
                            Promise.resolve(this.use(target));
                            played = true;
                        }
                    }
                    if(played) {
                        hand.splice(hand.indexOf(this), 1);
                        if(this.flags.includes("exhausted")) {
                            exhaustPile.push(this);
                            drawCard(hasBuff("Dark Embrace"));
                            if(hasBuff("Feel No Pain") > 0) {gainBuff("Block", hasBuff("Feel No Pain"));}
                            for(let r of relics) {if(r.trigger == "on_exhaust") {r.effect();}}
                        } else {
                            discardPile.push(this);
                        }
                        await this.play_success();
                    }
                    updateHtml();
                }
                async play_success() {
                    if(this.type == "Skill") {
                        stats.skillsThisTurn += 1;
                        for(let e of enemies) {
                            if(e.hasBuff("Enrage") > 0) {e.gainBuff("Strength", e.hasBuff("Enrage"));}
                        }
                        for(let r of relics) {
                            if(r.trigger == "on_skill") {r.effect();}
                            if(r.trigger == "3_skills" && stats.skillsThisTurn % 3 == 0) {r.effect();}
                        }
                    }
                    if(this.type == "Power") {
                        for(let r of relics) {if(r.trigger == "on_power") {r.effect();}}
                    }
                    if(this.type == "Attack") {
                        stats.attacksThisTurn += 1;
                        if(hasBuff("Rage") > 0) {gainBuff("Block", hasBuff("Rage"));}
                        if(hasBuff("Double Tap") > 0) {
                            loseBuff("Double Tap", 1);
                            hand.push(this);
                            discardPile.splice(discardPile.indexOf(this), 1);
                            if(this.cost != "X") {energy += this.cost;}
                            await this.play();
                        }
                        for(let r of relics) {
                            if(r.trigger == "on_attack") {r.effect();}
                            if(r.trigger == "3_attacks" && stats.attacksThisTurn % 3 == 0) {r.effect();}
                        }
                    }
                    if(this.name.toLowerCase().includes("strike")) {
                        for(let r of relics) {if(r.trigger == "strike") {r.effect();}}
                    }
                    if(this.type != "Attack") {
                        if(hasBuff("Hex") > 0) {
                            for(let i=0; i<hasBuff("Hex"); i++) {discardPile.push(statusCards["Dazed"]());}
                        }
                    }
                }
            }
            
            class Enemy {
                /*
                'attacks' is a list of objects. Each one has a 'desc' and an 'effect'.
                The effect is a function that takes this object as a parameter (because it cannot use 'this').
                */
                constructor(name, hp, attacks, flags=[]) {
                    this.name = name;
                    this.number = Math.random();
                    this.hp = hp;
                    this.maxHp = hp;
                    this.attacks = attacks;
                    this.flags = flags;
                    this.buffs = [];
                    this.intent = (this.flags.includes("randomize") ? choice(attacks) : attacks[0]);
                }
                attack() {
                    this.intent.effect(this);
                    if(this.flags.includes("randomize")) {
                        // We need to change attacks each time.
                        let newIntent = choice(this.attacks);
                        while(newIntent == this.intent) {
                            newIntent = choice(this.attacks);
                        }
                        this.intent = newIntent;
                    } else if(this.attacks.indexOf(this.intent) + 1 == this.attacks.length && !(this.flags.includes("no-repeat"))) {
                        // Repeat is allowed and we are at the end: restart.
                        this.intent = this.attacks[0];
                    } else if(this.attacks.indexOf(this.intent) + 1 != this.attacks.length) {
                        // Else if we have something to go to: go to it.
                        this.intent = this.attacks[this.attacks.indexOf(this.intent) + 1];
                    }
                }
                hasBuff(name) {
                    for(let b of this.buffs) {if(b.name == name) {return b.amt;}}
                    return 0;
                }
                gainBuff(name, amt) {
                    if(debuffs.includes(name) && this.hasBuff("Artifact") > 0) {this.loseBuff("Artifact", 1); return;}
                    let newAmt = amt;
                    if(this.hasBuff("Frail") > 0 && name == "Block") {newAmt = Math.round(newAmt * 0.75);}
                    if(this.hasBuff("Dexterity") > 0 && name == "Block") {newAmt -= this.hasBuff("Dexterity");}
                    if(this.hasBuff("Minus Dexterity") > 0 && name == "Block") {newAmt -= this.hasBuff("Minus Dexterity");}
                    for(let b of this.buffs) {if(b.name == name) {b.amt += newAmt;return;}}
                    this.buffs.push({name: name, amt: newAmt});
                    if(name=="Vulnerable") {for(let r of relics) {if(r.trigger == "apply_vulnerable") {r.effect();}}}
                }
                loseBuff(name, amt=9999) {
                    for(let b of this.buffs) {
                        if(b.name == name) {
                            let prevAmt = b.amt;
                            if(amt >= b.amt) {this.buffs.splice(this.buffs.indexOf(b), 1);} else {b.amt -= amt;}
                            return;
                        }
                    }
                }
                dealDamage(amt) {
                    let finalAmt = amt;
                    if(hasBuff("Vulnerable") > 0) {finalAmt = Math.round(finalAmt * 1.5);}
                    if(this.hasBuff("Weak") > 0) {finalAmt = Math.round(finalAmt * 0.75);}
                    finalAmt += this.hasBuff("Strength");
                    if(hasBuff("Buffer") > 0 && finalAmt > hasBuff("Block")) {finalAmt = 0; loseBuff("Buffer", 1);}
                    
                    hp -= Math.max(0, finalAmt - hasBuff("Block"));
                    if(finalAmt - hasBuff("Block") > 0) {
                        stats.timesLostHp++;
                        if(hasBuff("Thorns") > 0) {dealDamage(this, hasBuff("Thorns")); updateHtml();}
                        for(let r of relics) {if(r.trigger == "lose_hp") {r.effect();}}
                        getId("html").style.background = "#600";
                        let normalColor1 = function(){getId("html").style.background = "#511";}
                        let normalColor2 = function(){getId("html").style.background = "#411";}
                        let normalColor3 = function(){getId("html").style.background = "#322";}
                        let normalColor4 = function(){getId("html").style.background = "#222";}
                        setTimeout(normalColor1, 40);
                        setTimeout(normalColor2, 80);
                        setTimeout(normalColor3, 120);
                        setTimeout(normalColor4, 160);
                    }
                    loseBuff("Block", finalAmt);
                }
            }
            
            class Relic {
                constructor(name, desc, trigger, effect) {
                    this.name = name;
                    this.desc = desc;
                    this.trigger = trigger;
                    this.use = effect;
                }
                effect(n=undefined) {
                    if(n) {this.use(n);} else {this.use();}
                }
            }
            
            function hasBuff(name) {
                for(let b of buffs) {if(b.name == name) {return b.amt;}}
                return 0;
            }
            function gainBuff(name, amt) {
                if(debuffs.includes(name) && hasBuff("Artifact") > 0) {loseBuff("Artifact", 1); return;}
                let newAmt = amt;
                if(hasBuff("Frail") > 0           && name == "Block") {newAmt = Math.round(newAmt * 0.75);}
                if(hasBuff("Dexterity") > 0       && name == "Block") {newAmt += hasBuff("Dexterity");}
                if(hasBuff("Minus Dexterity") > 0 && name == "Block") {newAmt -= hasBuff("Minus Dexterity");}
                if(hasBuff("Juggernaut") > 0      && name == "Block") {dealDamage(choice(enemies), hasBuff("Juggernaut"));}
                for(let b of buffs) {if(b.name == name) {b.amt += newAmt;return;}}
                buffs.push({name: name, amt: newAmt});
            }
            function loseBuff(name, amt=9999) {
                for(let b of buffs) {
                    if(b.name == name) {
                        let prevAmt = b.amt;
                        if(amt >= b.amt) {buffs.splice(buffs.indexOf(b), 1);} else {b.amt -= amt;}
                        return;
                    }
                }
            }
            let timeouts = [];
            let prevNum = 0;
            function dealDamage(actor, amt, shiv=false) {
                let finalAmt = amt;
                if(shiv) {finalAmt += hasBuff("Accuracy");}
                if(actor.hasBuff("Vulnerable")) { finalAmt = Math.round(finalAmt * 1.5); }
                if(hasBuff("Weak")) { finalAmt = Math.round(finalAmt * 0.75); }
                finalAmt += hasBuff("Strength");
                finalAmt -= hasBuff("Minus Strength");
                actor.hp -= Math.max(0, finalAmt - actor.hasBuff("Block"));
                if(finalAmt - actor.hasBuff("Block") > 0) {
                    if(stats.hasAttacked == false) {
                        stats.hasAttacked = true;
                        for(let r of relics) {if(r.trigger == "first_attack") {r.effect();}}
                        if(hasBuff("Vigor") > 0) {
                            loseBuff("Strength", hasBuff("Vigor"));
                            loseBuff("Vigor");
                        }
                    }
                }
                
                let num = enemies.indexOf(actor);
                let dn = getId("damageNumber"+num);
                let dealt = Math.max(0, finalAmt - actor.hasBuff("Block"));
                if(dealt > 0) {
                    prevNum = prevNum + dealt;
                    dn.innerHTML = prevNum; // dealt has already been added to prevNum
                    dn.style.top = getId("enemy_"+actor.number).getBoundingClientRect().top - 10;
                    dn.style.left = getId("enemy_"+actor.number).getBoundingClientRect().left -
                        (10 + prevNum.toString().length * 25); // dealt has already been added to prevNum
                    dn.style.fontSize = "50px";
                    dn.style.color = "yellow";
                    for(let i of timeouts[num]) {clearTimeout(i);}
                    timeouts[num] = [];
                    dn.style.opacity = "1";
                    for(let i=0; i<50; i++) {
                        timeouts[num].push(setTimeout(function(){dn.style.opacity = (49-i)/50}, i*5 + 750));
                    }
                    timeouts[num].push(setTimeout(function(){timeouts[num] = []; prevNum = 0;}, 1000));
                } else if(finalAmt > 0) {
                    prevNum = 0;
                    dn.innerHTML = "Block";
                    dn.style.top = getId("enemy_"+actor.number).getBoundingClientRect().top;
                    dn.style.left = getId("enemy_"+actor.number).getBoundingClientRect().left - 90;
                    dn.style.fontSize = "30px";
                    dn.style.color = "skyblue";
                    for(let i of timeouts[num]) {clearTimeout(i);}
                    timeouts[num] = [];
                    dn.style.opacity = "1";
                    for(let i=0; i<50; i++) {
                        timeouts[num].push(setTimeout(function(){dn.style.opacity = (49-i)/50}, i*20));
                    }
                    timeouts[num].push(setTimeout(function(){timeouts[num] = [];}, 1000));
                }
                
                actor.loseBuff("Block", finalAmt);
                if(finalAmt > 0 && actor.hasBuff("Thorns") > 0) {actor.dealDamage(actor.hasBuff("Thorns")); updateHtml();}
            }
            let buffDesc = {
                "Block": "Until next turn, prevents [AMT] damage.",
                "Vulnerable": "Take 50% more damage for [AMT] turn[s].",
                "Weak": "Deal 25% less damage for [AMT] turn[s].",
                "Strength": "Attacks deal [AMT] more damage.",
                "Dexterity": "Cards gain you [AMT] more Block.",
                "Strength Down": "At the end of this turn, lose [AMT] Strength.",
                "No Draw": "Cannot draw cards for [AMT] turn[s].",
                "Combust": "At the end of your turn, lose 1 HP and deal [DAMT] damage to ALL enemies.",
                "Dark Embrace": "When a card is Exhausted, draw [AMT] card[s].",
                "Thorns": "When recieving unblocked damage, deal [DAMT] damage back.",
                "Ritual": "At end of turn, gain [AMT] Strength.",
                "Frail": "Gain 25% less Block for [AMT] turn[s].",
                "Enrage": "When you play a Skill, gains [AMT] Strength.",
                "Minus Strength": "Attacks deal [AMT] less damage.",
                "Minus Dexterity": "Gain [AMT] less block from cards.",
                "Evolve": "Whenever you draw a Status card, draw [AMT] card[s].",
                "Pen Nib": "When you get 10 Pen Nib, deal 10 damage.",
                "Feel No Pain": "When a card is Exausted, gain [BAMT] Block.",
                "Fire Breathing": "Whenever you draw a Status card, deal [DAMT] damage to ALL enemies.",
                "Metallicize": "Start each turn with [BAMT] Block.",
                "Rage": "For each Attack you play this turn, gain [BAMT] Block.",
                "Rampage": "Increase Rampage's damage by [AMT].",
                "Barricade": "Block is not removed at the start of your turn.",
                "Berserk": "Gain [AMT] more energy each turn.",
                "Brutality": "At the start of your turn, lose 1 HP and draw [AMT] card[s].",
                "Double Tap": "The next Attack you play is played [AMT] more time[s]",
                "Juggernaut": "Whenever you gain Block, deal [DAMT] damage to a random enemy.",
                "Regen": "At end of turn, heal [AMT] HP and reduce Regen by 1.",
                "Dexterity Down": "At end of turn, lose [AMT] Dexterity.",
                "Artifact": "Negates the next [AMT] debuff[s].",
                "Hex": "When you play a non-Attack card, add [AMT] Dazed to your discard pile.",
                "Draw Reduction": "Draw 1 fewer card for [AMT] turn[s].",
                "Buffer": "Prevent the first [AMT] unblocked hit[s].",
                "Next Turn Block": "Gain [BAMT] Block next turn.",
                "Vigor": "[AMT] of your Strength only applies to 1st attack.",
                "Next Turn Energy": "Gain [AMT] more energy next turn.",
                "Poison": "Lose [AMT] HP at start of turn. Poison goes down each turn.",
                "Accuracy": "Shivs deal [AMT] more damage.",
                "Blur": "Keep your Block for [AMT] turn[s].",
                "Infinite Blades": "Get [AMT] Shiv[s] each turn.",
                "Noxious Fumes": "At the start of your turn, apply [AMT] Poison to ALL enemies.",
                "Next Turn Cards": "Draw [AMT] more card[s] next turn."
            };
            let debuffs = ["Vulnerable", "Weak", "Strength Down", "No Draw", "Frail", "Minus Strength", "Minus Dexterity", "Dexterity Down", "Hex", "Draw Reduction", "Poison"];
            let statusCards = {
                "Wound": () => new Card("Wound", 0, "Status", "Unplayable.", function(enemy){}, ["unplayable"]),
                "Dazed": () => new Card("Dazed", 0, "Status", "Unplayable. Ethereal.", function(enemy){}, ["unplayable", "ethereal"]),
                "Slimed": () => new Card("Slimed", 1, "Status", "Exhaust.", function(enemy){}, ["exhausted"]),
                "Burn": () => new Card("Burn", 0, "Status", "Unplayable. Lose 1 HP at end of turn.", function(enemy){}, ["unplayable", "burning"])
            };
            
            function showMap() {
                if(mapY >= 15) {
                    mapY = 0;
                    hp = maxHp;
                    mapGen();
                    maxEnergy += 1;
                    if(actNum == 1) {
                        actNum = 2;
                        alert("Congratulations! You completed Act I! That's 1/3 of the game!");
                    } else if(actNum == 2) {
                        actNum = 3;
                        alert("Congratulations! You completed Act II! That's 2/3 of the game!");
                    } else if(actNum == 3) {
                        actNum = 999;
                        alert("Congratulations! You completed Act III! You Win!");
                    }
                }
                updateStatLine();
                getId("rewardsScreen").style.display = "none";
                getId("restScreen").style.display = "none";
                getId("merchantScreen").style.display = "none";
                if(actNum > 3) {return;}
                getId("mapScreen").style.display = "block";
                getId("mapScreen").innerHTML = "Select your next room...";
                for(let floor in map) {
                    let floorElem = document.createElement("tr");
                    for(let node in map[floor]) {
                        let nodeElem = document.createElement("td");
                        if(map[floor][node] != "") {
                            let nodeButton = document.createElement("button");
                            nodeButton.innerHTML = map[floor][node]+"<span class='txt'>"+
                                (map[floor][node]=="enemy" ? "Fight some monsters. Gain gold and add a card if you win." : 
                                  (map[floor][node]=="elite" ? "Fight a strong monster. Gain gold, add a card, and get a relic if you win." : 
                                    (map[floor][node]=="rest&nbsp;" ? "Rest and heal some HP." : 
                                     (map[floor][node]=="shop&nbsp;" ? "Buy cards and relics at the shop.<br/>Costs around $60 for a card, $200 for a relic." : "Fight a Boss. Cool stuff if you win.")))
                                )+"</span>";
                            nodeButton.setAttribute("class", "tt notbig");
                            if(floor-1 == mapY && Math.abs(node-mapX) <= 1) {
                                nodeButton.setAttribute("onclick", `gotoMap(${floor}, ${node});`);
                            } else if(floor == mapY && node == mapX) {
                                nodeButton.innerHTML = "(You)";
                            } else {
                                nodeButton.setAttribute("class", "nonbutton notbig");
                            }
                            nodeElem.appendChild(nodeButton);
                        }
                        floorElem.appendChild(nodeElem);
                    }
                    getId("mapScreen").appendChild(floorElem);
                }
            }
            function gotoMap(y, x) {
                mapY = y;
                mapX = x;
                timerRunning = true; updateStatLine();
                let readyBattle = function() {
                    getId("mapScreen").style.display = "none";
                    getId("gameScreen").style.display = "block";
                    drawPile = shuffle(deck.slice(0)); // no shallow copy
                    discardPile = [];
                    exhaustPile = [];
                    hand = [];
                    buffs = [];
                    energy = 0; // no ice cream hax
                    stats = {timesLostHp: 0, hasAttacked: false, attacksThisTurn: 999, skillsThisTurn: 999, rested: stats.rested};
                    target = enemies[0];
                    for(let r of relics) {if(r.trigger == "combat_start") {r.effect();}}
                    for(let card of drawPile) {
                        if(card.flags.includes("innate")) {
                            drawPile.splice(drawPile.indexOf(card), 1);
                            hand.push(card);
                        }
                    }
                    timeouts = enemies.map(x=>[]);
                    startTurn();
                }
                if(map[y][x] == "enemy") {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleEnemies.slice(0))();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleEnemies_act2.slice(0))();
                    } else {
                        nme = () => choice(possibleEnemies_act3.slice(0))();
                    }
                    if(mapY >= 2) {enemies = [nme(), nme()]}
                    else {enemies = [nme()]}
                    eliteBattle = false;
                    bossBattle = false;
                    readyBattle();
                } else if(map[y][x] == "elite") {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleElites.slice(0))();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleElites_act2.slice(0))();
                    } else {
                        nme = () => choice(possibleElites_act3.slice(0))();
                    }
                    enemies = [nme()];
                    eliteBattle = true;
                    bossBattle = false;
                    readyBattle();
                } else if(map[y][x].includes("BOSS")) {
                    let nme;
                    if(actNum == 1) {
                        nme = () => choice(possibleBosses.slice(0))();
                    } else if(actNum == 2) {
                        nme = () => choice(possibleBosses_act2.slice(0))();
                    } else {
                        nme = () => choice(possibleBosses_act3.slice(0))();
                    }
                    enemies = [nme()];
                    eliteBattle = false;
                    bossBattle = true;
                    readyBattle();
                } else if(map[y][x] == "rest&nbsp;") {
                    getId("mapScreen").style.display = "none";
                    getId("restScreen").style.display = "block";
                } else if(map[y][x] == "shop&nbsp;") {
                    getId("mapScreen").style.display = "none";
                    getId("merchantScreen").style.display = "block";
                    getId("merchantScreen").innerHTML = "";
                    offers = [];
                    for(let i=0; i<6; i++) {
                        let offer = randCard()();
                        let cardCost = Math.round(Math.random()*37 + 45); // cost: 45g to 82g
                        offers.push({index: i, price: cardCost, offer: offer});
                        if(i==0) {cardCost = Math.round(cardCost * 0.45);}
                        if(i==5) {cardCost = Math.round(Math.random()*30 + 135); offer = randRareCard()();} // 6th card is rare
                        let cardElem = document.createElement("tr");
                        let nameWrapper = document.createElement("td");
                        let nameElem = document.createElement("button");
                        let costElem = document.createElement("td");
                        cardElem.setAttribute("id", `cardElem_${i}`);
                        nameElem.setAttribute("id", `cardName_${i}`);
                        nameElem.innerHTML = offer.name+"<span class='txt'>"+addCircle(offer.cost.toString())+" "+offer.type+"<br/>"+unformat(offer.desc)+"</span>";
                        if(gold >= cardCost) {
                            if(i==0) {
                                nameElem.setAttribute("class", "Skill tt");
                            } else {
                                nameElem.setAttribute("class", "tt");
                            }
                        } else {
                            nameElem.setAttribute("class", "tt unplayable");
                        }
                        nameElem.setAttribute("onclick", `if(gold >= ${cardCost}) {
gold -= ${cardCost};
deck.push(new Card("${offer.name}", ${offer.cost}, "${offer.type}", "${offer.desc}", ${offer.use}, ${JSON.stringify(offer.flags)}));
getId("cardElem_${i}").style.display = "none";
updateStatLine();
updateShopScreen();
}
                        `);
                        costElem.innerHTML = "Cost: $"+cardCost;
                        
                        nameWrapper.appendChild(nameElem);
                        cardElem.appendChild(nameWrapper);
                        cardElem.appendChild(costElem);
                        getId("merchantScreen").appendChild(cardElem);
                    }
                    for(let i=0; i<3; i++) {
                        let offer = choice(relicPool)();
                        let relicCost = Math.round(Math.random()*119 + 143);
                        offers.push({index: i+100, price: relicCost, offer: offer});
                        let relicElem = document.createElement("tr");
                        let nameWrapper = document.createElement("td");
                        let nameElem = document.createElement("button");
                        let costElem = document.createElement("td");
                        relicElem.setAttribute("id", `relicElem_${i}`);
                        nameElem.setAttribute("id", `relicName_${i}`);
                        nameElem.innerHTML = offer.name+"<span class='txt'>"+offer.desc+"</span>";
                        if(gold >= relicCost) {
                            nameElem.setAttribute("class", "Status tt");
                        } else {
                            nameElem.setAttribute("class", "Status tt unplayable");
                        }
                        nameElem.setAttribute("onclick", `if(gold >= ${relicCost}) {
gold -= ${relicCost};
let r = new Relic("${offer.name}", "${offer.desc}", "${offer.trigger}", ${offer.use});
relics.push(r);
if(r.trigger=='on_pickup') {r.effect();}
getId("relicElem_${i}").style.display = "none";
updateStatLine();
updateShopScreen();
}
                        `);
                        costElem.innerHTML = "Cost: $"+relicCost;
                        
                        nameWrapper.appendChild(nameElem);
                        relicElem.appendChild(nameWrapper);
                        relicElem.appendChild(costElem);
                        getId("merchantScreen").appendChild(relicElem);
                    }
                    let continueElem = document.createElement("tr");
                    let continueWrapper = document.createElement("td");
                    let continueBtn = document.createElement("button");
                    continueBtn.innerHTML = "<span style='text-decoration:underline'>C</span>ontinue";
                    continueBtn.setAttribute("onclick", "showMap();");
                    continueWrapper.appendChild(continueBtn);
                    continueElem.appendChild(continueWrapper);
                    getId("merchantScreen").appendChild(continueElem);
                }
            }
            let offers = [];
            function updateShopScreen() {
                for(let i of offers) {
                    if(i.index >= 100) {
                        let relicElem = getId("relicName_"+(i.index-100));
                        if(gold >= i.price) {
                            relicElem.setAttribute("class", "Status tt");
                        } else {
                            relicElem.setAttribute("class", "unplayable tt");
                        }
                    } else {
                        let cardElem = getId("cardName_"+i.index);
                        if(gold >= i.price) {
                            if(i.index==0) {
                                cardElem.setAttribute("class", "Skill tt");
                            } else {
                                cardElem.setAttribute("class", "tt");
                            }
                        } else {
                            cardElem.setAttribute("class", "tt unplayable");
                        }
                    }
                }
            }
            
            //
            // Basics
            //
            let strike = () => new Card("Strike", 1, "Attack", "Deal [DAM6] damage.", function(enemy){
                dealDamage(enemy, 6);
            });
            let defend = () => new Card("Defend", 1, "Skill", "Gain [BLK5] Block.", function(enemy){
                gainBuff("Block", 5);
            });
            let bash = () => new Card("Bash", 2, "Attack", "Deal [DAM8] damage, apply 2 Vulnerable.", function(enemy){
                dealDamage(enemy, 8); enemy.gainBuff("Vulnerable", 2);
            });
            
            //
            // Commons
            //
            let bodySlam = () => new Card("Body Slam", 1, "Attack", "Deal damage equal to your Block. ([BLOCK] damage)", function(enemy){
                dealDamage(enemy, hasBuff("Block"));
            });
            let clash = () => new Card("Clash", 0, "Attack","Deal [DAM14] damage if all cards in your hand are Attacks.", function(enemy){
                if(!hand.map(x=>x.type=="Attack").includes(false)) {dealDamage(enemy, 14);} else {alert("Failed to play Clash: There are non-Attack cards in your hand.");}
            });
            let cleave = () => new Card("Cleave", 1, "Attack", "Deal [DAM8] damage to ALL enemies.", function(enemy){
                for(let e of enemies){dealDamage(e, 8);}
            });
            let clothesline = () => new Card("Clothesline", 2, "Attack", "Deal [DAM12] damage, apply 2 Weak.", function(enemy){
                dealDamage(enemy, 12); enemy.gainBuff("Weak", 2);
            });
            let flex = () => new Card("Flex", 0, "Skill", "Gain 2 Strength. At the end of your turn, lose 2 Strength.", function(enemy){
                gainBuff("Strength", 2); gainBuff("Strength Down", 2);
            });
            let headbutt = () => new Card("Headbutt", 1, "Attack", "Deal [DAM9] damage. Put a card from your discard pile on top of your draw pile.", async function(enemy){
                dealDamage(enemy, 9);
                let chosen = await choose(discardPile, "Choose a card to put on top of your Draw Pile.");
                if(chosen) {
                    drawPile.push(chosen);
                    discardPile.splice(discardPile.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let heavyBlade = () => new Card("Heavy Blade", 2, "Attack", "Deal [HEAVYBLADE] damage. Strength affects the damage 3 times.", function(enemy){
                dealDamage(enemy, 14 + 2 * hasBuff("Strength"));
            });
            let ironWave = () => new Card("Iron Wave", 1, "Attack", "Gain [BLK5] Block. Deal [DAM5] damage.", function(enemy){
                dealDamage(enemy, 5); gainBuff("Block", 5);
            });
            let pommelStrike = () => new Card("Pommel Strike", 1, "Attack", "Deal [DAM9] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 9); drawCard();
            });
            let shrugItOff = () => new Card("Shrug it Off", 1, "Skill", "Gain [BLK8] Block. Draw a card.", function(enemy){
                gainBuff("Block", 8); drawCard();
            });
            let swordBoomerang = () => new Card("Sword Boomerang", 1, "Attack", "Deal [DAM3] damage to a random enemy 3 times.", function(enemy){
                let boom = () => dealDamage(choice(enemies), 3);
                boom(); boom(); boom();
            });
            let thunderclap = () => new Card("Thunderclap", 1, "Attack", "Deal [DAM4] damage and apply 1 Vulnerable to ALL enemies.", function(enemy){
                for(let e of enemies){dealDamage(e, 4); e.gainBuff("Vulnerable", 1);}
            });
            let trueGrit = () => new Card("True Grit", 1, "Skill", "Gain [BLK7] Block. Exhaust a random card in your hand.", function(enemy){
                gainBuff("Block", 7); let c=choice(hand); hand.splice(hand.indexOf(c), 1); exhaustPile.push(c);
            });
            let twinStrike = () => new Card("Twin Strike", 1, "Attack", "Deal [DAM5] damage twice.", function(enemy){
                dealDamage(enemy, 5); dealDamage(enemy, 5);
            });
            let wildStrike = () => new Card("Wild Strike", 1, "Attack", "Deal [DAM12] damage. Shuffle a Wound into your discard pile.", function(enemy){
                dealDamage(enemy, 12); discardPile.push(statusCards["Wound"]());
            });
            
            //
            // Uncommons
            //
            let battleTrance = () => new Card("Battle Trance", 0, "Skill", "Draw 3 cards. You cannot draw additional cards this turn.", function(enemy){
                drawCard(3); gainBuff("No Draw", 1);
            });
            let bloodForBlood = () => new Card("Blood for Blood", 4, "Attack", "Deal [DAM18] damage. -1 cost each time you lose HP. (Costs [BLOOD4BLOOD] energy)", function(enemy){
                dealDamage(enemy, 18);
            }, ["blood4blood"]);
            let bloodletting = () => new Card("Bloodletting", 0, "Skill", "Lose 3 HP. Gain 2 energy.", function(enemy){
                hp -= 3; energy += 2;
            });
            let burningPact = () => new Card("Burning Pact", 1, "Skill", "Exhaust 1 card. Draw 2 cards.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name != "Burning Pact"), "Choose a card to Exhaust.");
                if(chosen) {
                    hand.splice(hand.indexOf(chosen), 1);
                    exhaustPile.push(chosen);
                    drawCard(2);
                } else {
                    alert("Failed to play Burning Pact: No remaining cards in hand.");
                }
                updateHtml();
            });
            let carnage = () => new Card("Carnage", 2, "Attack", "Ethereal. Deal [DAM20] damage.", function(enemy){
                dealDamage(enemy, 20);
            }, ["ethereal"]);
            let combust = () => new Card("Combust", 1, "Power", "At the end of your turn, lose 1 HP and deal [DAM5] damage to ALL enemies.", function(enemy){
                gainBuff("Combust", 5);
            }, ["exhausted"]);
            let darkEmbrace = () => new Card("Dark Embrace", 2, "Power", "Whenever a card is Exhausted, draw a card.", function(enemy){
                gainBuff("Dark Embrace", 1);
            }, ["exhausted"]);
            let disarm = () => new Card("Disarm", 1, "Skill", "Enemy gets -2 Strength. Exhaust.", function(enemy){
                enemy.gainBuff("Minus Strength", 2);
            }, ["exhausted"]);
            let dropkick = () => new Card("Dropkick", 1, "Attack", "Deal [DAM5] damage. If the enemy has Vulnerable, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 5);
                if(enemy.hasBuff("Vulnerable") > 0) {
                    energy++;
                    drawCard();
                }
            });
            let dualWield = () => new Card("Dual Wield", 1, "Skill", "Copy an Attack or Power card in your hand.", async function(enemy){
                let chosen = await choose(hand.filter(x=>["Attack","Power"].includes(x.type)), "Choose a card to copy.");
                if(chosen) {
                    hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use, chosen.flags));
                    updateHtml();
                } else {
                    alert("Failed to play Dual Wield: No Attack or Power cards in hand.");
                }
            });
            let entrench = () => new Card("Entrench", 2, "Skill", "Double your Block.", function(enemy){
                if(hasBuff("Block")>0) {gainBuff("Block", hasBuff("Block"));}
            });
            let evolve = () => new Card("Evolve", 1, "Power", "Whenever you draw a Status card, draw another card.", function(enemy){
                gainBuff("Evolve", 1);
            }, ["exhausted"]);
            let feelNoPain = () => new Card("Feel No Pain", 1, "Power", "When a card is Exhausted, gain [BLK3] Block.", function(enemy){
                gainBuff("Feel No Pain", 3);
            }, ["exhausted"]);
            let fireBreathing = () => new Card("Fire Breathing", 1, "Power", "Whenever you draw a Status card, deal 6 damage to ALL enemies", function(enemy){
                gainBuff("Fire Breathing", 6);
            }, ["exhausted"]);
            let flameBarrier = () => new Card("Flame Barrier", 2, "Skill", "Gain [BLK12] Block and 2 Thorns.", function(enemy){
                gainBuff("Block", 12); gainBuff("Thorns", 2);
            });
            let ghostlyArmor = () => new Card("Ghostly Armor", 1, "Skill", "Ethereal. Gain [BLK10] Block.", function(enemy){
                gainBuff("Block", 10);
            }, ["ethereal"]);
            let hemokinesis = () => new Card("Hemokinesis", 1, "Attack", "Lose 2 HP. Deal [DAM15] damage.", function(enemy){
                hp -= 2; dealDamage(enemy, 15);
            });
            let infernalBlade = () => new Card("Infernal Blade", 0, "Skill", "Add a random Attack to your hand. Exhaust.", function(enemy){
                let extraCard = randCard()(); // looks weird ik
                while(extraCard.type != "Attack") {extraCard = randCard()();}
                hand.push(extraCard);
            }, ["exhausted"]);
            let inflame = () => new Card("Enflame", 1, "Power", "Gain 2 Strength.", function(enemy){
                gainBuff("Strength", 2);
            }, ["exhausted"]);
            let intimidate = () => new Card("Intimidate", 0, "Skill", "Apply 1 Weak to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {e.gainBuff("Weak", 1);}
            }, ["exhausted"]);
            let metallicize = () => new Card("Metallicize", 1, "Power", "Start each turn with [BLK3] Block.", function(enemy){
                gainBuff("Metallicize", 3);
            }, ["exhausted"]);
            let powerThrough = () => new Card("Power Through",1,"Skill","Add 2 Wounds to your hand. Gain [BLK15] Block.",function(enemy){
                hand.push(statusCards["Wound"]()); hand.push(statusCards["Wound"]()); gainBuff("Block", 15);
            });
            let pummel = () => new Card("Pummel", 2, "Attack", "Deal [DAM2] damage 6 times.", function(enemy){
                dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);dealDamage(enemy,2);
            });
            let rage = () => new Card("Rage", 0, "Skill", "For each Attack you play this turn, gain [BLK3] Block.", function(enemy){
                gainBuff("Rage", 3);
            });
            let rampage = () => new Card("Rampage", 1, "Attack", "Deal [RAMPAGE] damage. This card deals 5 more damage this combat.", function(enemy){
                dealDamage(enemy, 8 + hasBuff("Rampage")); gainBuff("Rampage", 5);
            });
            let recklessCharge = () => new Card("Reckless Charge",0,"Attack","Deal [DAM7] damage. Get a Dazed card.",function(enemy){
                dealDamage(enemy, 7); discardPile.push(statusCards["Dazed"]());
            });
            let secondWind = () => new Card("Second Wind", 1, "Skill", "Exhaust all non-Attack cards in your hand. Gain [BLK5] Block for each card Exhausted.", function(enemy){
                for(let card of hand) {
                    if(card.type != "Attack") {
                        exhaustPile.push(card);
                        hand.splice(hand.indexOf(card), 1);
                        gainBuff("Block", 5);
                    }
                }
            });
            let seeingRed = () => new Card("Seeing Red", 0, "Skill", "Gain 1 energy. Exhaust.", function(enemy){
                energy += 1;
            }, ["exhausted"]);
            let severSoul = () => new Card("Sever Soul", 2, "Attack", "Exhaust all non-Attack cards in your hand. Deal [DAM16] damage.", function(enemy){
                for(let card of hand) {
                    if(card.type != "Attack") {
                        exhaustPile.push(card);
                        hand.splice(hand.indexOf(card), 1);
                    }
                }
                dealDamage(enemy, 16);
            });
            let spotWeakness = () => new Card("Spot Weakness", 1, "Skill", "If the enemy intends to attack, gain 3 Strength.", function(enemy){
                if(enemy.intent.intent.includes("attack")) {
                    gainBuff("Strength", 3);
                } else {
                    alert("Failed to play Spot Weakness: That enemy does not intend to attack.");
                }
            });
            let uppercut = () => new Card("Uppercut", 2, "Attack", "Deal [DAM13] damage. Apply 1 Weak and Vulnerable.", function(enemy){
                dealDamage(enemy, 13); enemy.gainBuff("Weak", 1); enemy.gainBuff("Vulnerable", 1);
            });
            let whirlwind = () => new Card("Whirlwind", "X", "Attack", "Deal [DAM5] damage to ALL enemies X times.", function(enemy){
                for(let e of enemies){dealDamage(e, 5);}
            });
            
            //
            // Rares
            //
            let barricade = () => new Card("Barricade", 3, "Power", "Block is not removed at the start of your turn.", function(enemy){
                gainBuff("Barricade", 1);
            }, ["exhausted"]);
            let berserk = () => new Card("Berserk", 0, "Power", "Gain Vulnerable for 2 turns, but gain 1 more energy each turn.", function(enemy){
                gainBuff("Vulnerable", 3); gainBuff("Berserk", 1);
            }, ["exhausted"]);
            let bludgeon = () => new Card("Bludgeon", 3, "Attack", "Deal [DAM32] damage.", function(enemy){
                dealDamage(enemy, 32);
            });
            let brutality = () => new Card("Brutality", 0, "Power", "At the start of your turn, lose 1 HP and draw 1 more card.", function(enemy){
                gainBuff("Brutality", 1);
            }, ["exhausted"]);
            let demonForm = () => new Card("Demonic Ritual", 3, "Power", "At the end of your turn, gain 2 Strength.", function(enemy){
                gainBuff("Ritual", 2);
            }, ["exhausted"]);
            let doubleTap = () => new Card("Double Tap", 1, "Skill", "Your next Attack is played twice.", function(enemy){
                gainBuff("Double Tap", 1);
            }, ["exhausted"]);
            let exhume = () => new Card("Exhume", 1, "Skill", "Put a card from your exhaust pile in your hand. Exhaust.", async function(enemy){
                let chosen = await choose(exhaustPile, "Choose a card to put into your hand.");
                if(chosen) {
                    hand.push(chosen);
                    exhaustPile.splice(exhaustPile.indexOf(chosen), 1);
                    updateHtml();
                } else {
                    alert("Failed to play Exhume: Exhaust pile is empty.");
                }
            }, ["exhausted"]);
            let feed = () => new Card("Feed", 1, "Attack", "Enemy loses 10 HP. If they die from it, gain 3 Max HP. Exhaust.", function(enemy){
                if(enemy.hp <= 10) {maxHp += 3; hp += 3;}
                enemy.hp -= 10;
            }, ["exhausted"]);
            let impervious = () => new Card("Impervious", 2, "Skill", "Gain [BLK30] block. Exhaust.", function(enemy){
                gainBuff("Block", 30);
            }, ["exhausted"]);
            let juggernaut = () => new Card("Juggernaut", 2, "Power", "Whenever you gain Block, deal [DAM5] damage to a random enemy.", function(enemy){
                gainBuff("Juggernaut", 5);
            }, ["exhausted"]);
            let limitBreak = () => new Card("Limit Break", 1, "Skill", "Double your Strength. Exhaust.", function(enemy){
                if(hasBuff("Strength")>0) {gainBuff("Strength", hasBuff("Strength"));}
            }, ["exhausted"]);
            let offering = () => new Card("Offering", 0, "Skill", "Lose 6 HP. Gain 2 energy. Draw 3 cards. Exhaust.", function(enemy){
                hp -= 6; energy += 2; drawCard(3);
            }, ["exhausted"]);
            let reaper = () => new Card("Reaper", 2, "Attack", "Deal [DAM8] damage. Heal 8 HP. Exhaust.", function(enemy){
                dealDamage(enemy, 8); hp = Math.min(maxHp, hp + 8);
            }, ["exhausted"]);
            
            //
            // Silent Commons
            //
            let acrobatics = () => new Card("Acrobatics", 1, "Skill", "Draw 3 cards. Discard 1 card.", async function(enemy){
                drawCard(3);
                let chosen = await choose(hand.filter(x=>x.name!="Acrobatics"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let backflip = () => new Card("Backflip", 1, "Skill", "Gain [BLK5] Block. Draw 2 cards.", function(enemy){
                gainBuff("Block", 5); drawCard(2);
            });
            let bane = () => new Card("Bane", 1, "Attack", "Deal [DAM7] damage, twice if enemy has Poison.", function(enemy){
                dealDamage(enemy, 7); if(enemy.hasBuff("Poison")) {dealDamage(enemy, 7);}
            });
            let bladeDance = () => new Card("Blade Dance", 1, "Skill", "Add 3 Shivs to your hand.", function(enemy){
                addShivs(3);
            });
            let cloakAndDagger = () => new Card("Cloak and Dagger", 1, "Skill", "Gain [BLK6] Block. Add a Shiv to your hand.", function(enemy){
                gainBuff("Block", 6); addShivs(1);
            });
            let daggerSpray = () => new Card("Dagger Spray", 1, "Attack", "Deal [DAM4] damage to ALL enemies twice.", function(enemy){
                for(let e of enemies){dealDamage(e, 4);dealDamage(e, 4);}
            });
            let daggerThrow = () => new Card("Dagger Throw", 1, "Attack", "Deal [DAM9] damage. Draw a card. Discard a card.", async function(enemy){
                dealDamage(enemy, 9); drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Dagger Throw"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let deadlyPoison = () => new Card("Deadly Poison", 1, "Skill", "Apply 5 Poison.", function(enemy){
                enemy.gainBuff("Poison", 5);
            });
            let deflect = () => new Card("Deflect", 0, "Skill", "Gain [BLK4] Block.", function(enemy){
                gainBuff("Block", 4);
            });
            let dodgeAndRoll = () => new Card("Dodge and Roll", 1, "Skill", "Gain [BLK3] Block. Next turn, gain [BLK6] Block.", function(enemy){
                gainBuff("Block", 3); gainBuff("Next Turn Block", 6);
            });
            let flyingKnee = () => new Card("Flying Knee", 1, "Attack", "Deal [DAM8] damage. Gain 1 more energy next turn.", function(enemy){
                dealDamage(enemy, 8); gainBuff("Next Turn Energy", 1);
            });
            let outmaneuver = () => new Card("Outmaneuver", 1, "Skill", "Gain 2 more energy next turn.", function(enemy){
                gainBuff("Next Turn Energy", 2);
            });
            let poisonedStab = () => new Card("Poisoned Stab", 1, "Attack", "Deal [DAM6] damage. Apply 3 Poison.", function(enemy){
                dealDamage(enemy, 6); enemy.gainBuff("Poison", 3);
            });
            let prepared = () => new Card("Prepared", 0, "Skill", "Draw a card. Discard a card.", async function(enemy){
                drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            });
            let quickSlash = () => new Card("Quick Slash", 1, "Attack", "Deal [DAM8] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 8); drawCard();
            });
            let slice = () => new Card("Slice", 0, "Attack", "Deal [DAM6] damage.", function(enemy){
                dealDamage(enemy, 6);
            });
            let suckerPunch = () => new Card("Sucker Punch", 1, "Attack", "Deal [DAM7] damage. Apply 1 Weak.", function(enemy){
                dealDamage(enemy, 7); enemy.gainBuff("Weak", 1);
            });
            
            //
            // Silent Uncommons
            //
            let accuracy = () => new Card("Accuracy", 1, "Power", "Shivs deal 4 more damage.", function(enemy){
                gainBuff("Accuracy", 4);
            }, ["exhausted"]);
            let allOutAttack = () => new Card("All-Out Attack", 1, "Attack", "Deal [DAM10] damage to ALL enemies. Discard a random card.", function(enemy){
                for(let e of enemies) {dealDamage(e,10);}
                let chosen = choice(hand);
                discardPile.push(chosen);
                hand.splice(hand.indexOf(chosen), 1);
            });
            let backstab = () => new Card("Backstab", 0, "Attack", "Innate. Deal [DAM11] damage. Exhaust.", function(enemy){
                dealDamage(enemy, 11);
            }, ["exhausted", "innate"]);
            let blur = () => new Card("Blur", 1, "Skill", "Gain [BLK5] Block. Block is not removed next turn.", function(enemy){
                gainBuff("Blur", 1); gainBuff("Block", 5);
            });
            let bouncingFlask = () => new Card("Bouncing Flask", 2, "Skill", "Apply 9 Poison to a random enemy.", function(enemy){
                choice(enemies).gainBuff("Poison", 9);
            });
            let caltrops = () => new Card("Caltrops", 1, "Skill", "Gain 3 Thorns. Exhaust.", function(enemy){
                gainBuff("Thorns", 3);
            }, ["exhausted"]);
            let catalyst = () => new Card("Catalyst", 1, "Skill", "Double the enemy's Poison. Exhaust.", function(enemy){
                enemy.gainBuff("Poison", enemy.hasBuff("Poison"));
            }, ["exhausted"]);
            let concentrate = () => new Card("Concentrate", 0, "Skill", "Discard 3 cards. Gain 2 energy.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
                let chosen3 = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a third card to discard.");
                if(chosen3) {
                    discardPile.push(chosen3);
                    hand.splice(hand.indexOf(chosen3), 1);
                    updateHtml();
                }
                energy += 2;
            });
            let cripplingCloud = () => new Card("Crippling Cloud", 2, "Skill", "Apply 4 Poison and 2 Weak to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {e.gainBuff("Poison", 4); e.gainBuff("Weak", 2);}
            }, ["exhausted"]);
            let dash = () => new Card("Dash", 2, "Attack", "Deal 10 damage. Gain 10 Block.", function(enemy){
                gainBuff("Block", 10); dealDamage(enemy, 10);
            });
            let distraction = () => new Card("Distraction", 0, "Skill", "Add a random Skill to your hand. Exhaust.", function(enemy){
                let extraCard = randCard()(); // looks weird ik
                while(extraCard.type != "Skill") {extraCard = randCard()();}
                hand.push(extraCard);
            }, ["exhausted"]);
            let escapePlan = () => new Card("Escape Plan", 0, "Skill", "Draw a card. If it's a Skill, gain 3 Block.", function(enemy){
                drawCard();
                if(hand[hand.length - 1].type == "Skill") {gainBuff("Block", 3);}
            });
            let expertise = () => new Card("Expertise", 1, "Skill", "Draw cards until you have 6 in hand.", function(enemy){
                if(hand.length < 6) {drawCard(6 - hand.length);}
            });
            let finisher = () => new Card("Finisher", 1, "Attack", "Deal 6 damage for each Attack played this turn. (Deals [FINISHER] damage)", function(enemy){
                dealDamage(enemy, stats.attacksThisTurn * 6);
            });
            let footwork = () => new Card("Footwork", 1, "Power", "Gain 2 Dexterity.", function(enemy){
                gainBuff("Dexterity", 2);
            }, ["exhausted"]);
            let heelHook = () => new Card("Heel Hook", 1, "Attack", "Deal [DAM5] damage. If the enemy has Weak, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 5);
                if(enemy.hasBuff("Weak") > 0) {energy += 1; drawCard();}
            });
            let infiniteBlades = () => new Card("Infinite Blades", 1, "Power", "At the start of your turn, add a Shiv into your hand.", function(enemy){
                gainBuff("Infinite Blades", 1);
            }, ["exhausted"]);
            let legSweep = () => new Card("Leg Sweep", 2, "Skill", "Apply 2 Weak. Gain [DAM11] Block.", function(enemy){
                gainBuff("Block", 11); enemy.gainBuff("Weak", 2);
            });
            let noxiousFumes = () => new Card("Noxious Fumes", 1, "Power", "At the start of your turn, apply 2 Poison to ALL enemies.", function(enemy){
                gainBuff("Noxious Fumes", 2);
            }, ["exhausted"]);
            let predator = () => new Card("Predator", 2, "Attack", "Deal [DAM15] damage. Next turn, draw 2 more cards.", function(enemy){
                dealDamage(enemy, 15); gainBuff("Next Turn Cards", 2);
            });
            let skewer = () => new Card("Skewer", "X", "Attack", "Deal [DAM7] damage X times.", function(enemy){
                dealDamage(enemy, 7);
            });
            let terror = () => new Card("Terror", 1, "Skill", "Apply 999 Vulnerable. Exhaust.", function(enemy){
                enemy.gainBuff("Vulnerable", 999);
            }, ["exhausted"]);
            
            //
            // Upgraded Cards
            //
            let upgradedCards = {
                "Strike": () => new Card("Strike+", 1, "Attack", "Deal [DAM9] damage.", function(enemy){
                    dealDamage(enemy, 9);
                }), "Defend": () => new Card("Defend+", 1, "Skill", "Gain [BLK8] Block.", function(enemy){
                    gainBuff("Block", 8);
                }), "Bash": () => new Card("Bash+", 2, "Attack", "Deal [DAM10] damage, apply 3 Vulnerable.", function(enemy){
                    dealDamage(enemy, 10); enemy.gainBuff("Vulnerable", 3);
                }), "Body Slam": () => new Card("Body Slam+", 0, "Attack", "Deal damage equal to your Block. ([BLOCK] damage)", function(enemy){
                    dealDamage(enemy, hasBuff("Block"));
                }), "Clash": () => new Card("Clash+", 0, "Attack","Deal [DAM18] damage if all cards in your hand are Attacks.", function(enemy){
                    if(!hand.map(x=>x.type=="Attack").includes(false)) {dealDamage(enemy, 18);}
                }), "Cleave": () => new Card("Cleave+", 1, "Attack", "Deal [DAM11] damage to ALL enemies.", function(enemy){
                    for(let e of enemies){dealDamage(e, 11);}
                }), "Clothesline": () => new Card("Clothesline+", 2, "Attack", "Deal [DAM14] damage, apply 3 Weak.", function(enemy){
                    dealDamage(enemy, 14); enemy.gainBuff("Weak", 3);
                }), "Flex": () => new Card("Flex+", 0, "Skill", "Gain 4 Strength. At the end of your turn, lose 4 Strength.", function(enemy){
                    gainBuff("Strength", 4); gainBuff("Strength Down", 4);
                }), "Headbutt": () => new Card("Headbutt", 1, "Attack", "Deal [DAM12] damage. Put a card from your discard pile on top of your draw pile.", async function(enemy){
                    dealDamage(enemy, 12);
                    let chosen = await choose(discardPile, "Choose a card to put on top of your Draw Pile.");
                    if(chosen) {
                        drawPile = [chosen, ...drawPile];
                        discardPile.splice(discardPile.indexOf(chosen), 1);
                        updateHtml();
                    }
                }), "Heavy Blade": () => new Card("Heavy Blade+", 2, "Attack", "Deal [HEAVYBLADE+] damage. Strength affects the damage 5 times.", function(enemy){
                    dealDamage(enemy, 14 + 4 * hasBuff("Strength"));
                }), "Iron Wave": () => new Card("Iron Wave+", 1, "Attack", "Gain [BLK7] Block. Deal [DAM7] damage.", function(enemy){
                    dealDamage(enemy, 7); gainBuff("Block", 7);
                }), "Pommel Strike": () => new Card("Pommel Strike+", 1, "Attack", "Deal [DAM10] damage. Draw 2 cards.", function(enemy){
                    dealDamage(enemy, 10); drawCard(2);
                }), "Shrug it Off": () => new Card("Shrug it Off+", 1, "Skill", "Gain [BLK11] Block. Draw a card.", function(enemy){
                    gainBuff("Block", 11); drawCard();
                }), "Sword Boomerang": () => new Card("Sword Boomerang+", 1, "Attack", "Deal [DAM3] damage to a random enemy 4 times.", function(enemy){
                    dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3); dealDamage(choice(enemies), 3);
                }), "Thunderclap": () => new Card("Thunderclap+", 1, "Attack", "Deal [DAM7] damage and apply 1 Vulnerable to ALL enemies.", function(enemy){
                    for(let e of enemies){dealDamage(e, 7); e.gainBuff("Vulnerable", 1);}
                }), "True Grit": () => new Card("True Grit+", 1, "Skill", "Gain [BLK7] Block. Exhaust a card in your hand.", async function(enemy){
                    gainBuff("Block", 7);
                    let chosen = await choose(hand, "Choose a card to Exhaust.");
                    if(chosen) {
                        hand.splice(hand.indexOf(chosen), 1);
                        exhaustPile.push(chosen);
                        updateHtml();
                    }
                }), "Twin Strike": () => new Card("Twin Strike+", 1, "Attack", "Deal [DAM7] damage twice.", function(enemy){
                    dealDamage(enemy, 7); dealDamage(enemy, 7);
                }), "Wild Strike": () => new Card("Wild Strike+", 1, "Attack", "Deal [DAM17] damage. Shuffle a Wound into your discard pile.", function(enemy){
                    dealDamage(enemy, 17); discardPile.push(statusCards["Wound"]());
                }), "Battle Trance": () => new Card("Battle Trance+", 0, "Skill", "Draw 4 cards. You cannot draw additional cards this turn.", function(enemy){
                    drawCard(4); gainBuff("No Draw", 1);
                }), "Blood for Blood": () => new Card("Blood for Blood+", 4, "Attack", "Deal [DAM26] damage. -1 cost each time you lose HP. (Costs [BLOOD4BLOOD] energy)", function(enemy){
                    dealDamage(enemy, 26);
                }, ["blood4blood"]), "Bloodletting": () => new Card("Bloodletting+", 0, "Skill", "Lose 3 HP. Gain 3 energy.", function(enemy){
                    hp -= 3; energy += 3;
                }), "Burning Pact": () => new Card("Burning Pact+", 1, "Skill", "Exhaust 1 card. Draw 3 cards.", async function(enemy){
                    let chosen = await choose(hand, "Choose a card to Exhaust.");
                    if(chosen) {
                        hand.splice(hand.indexOf(chosen), 1);
                        exhaustPile.push(chosen);
                        drawCard(3);
                        updateHtml();
                    } else {
                        alert("Failed to play Burning Pact: No remaining cards in hand.");
                    }
                }), "Carnage": () => new Card("Carnage+", 2, "Attack", "Ethereal. Deal [DAM28] damage.", function(enemy){
                    dealDamage(enemy, 28);
                }, ["ethereal"]), "Combust": () => new Card("Combust+", 1, "Power", "At the end of your turn, lose 1 HP and deal [DAM7] damage to ALL enemies.", function(enemy){
                    gainBuff("Combust", 7);
                }, ["exhausted"]), "Dark Embrace+": () => new Card("Dark Embrace+", 1, "Power", "Whenever a card is Exhausted, draw a card.", function(enemy){
                    gainBuff("Dark Embrace", 1);
                }, ["exhausted"]), "Disarm": () => new Card("Disarm+", 1, "Skill", "Enemy gets -3 Strength. Exhaust.", function(enemy){
                    enemy.gainBuff("Minus Strength", 3);
                }, ["exhausted"]), "Dropkick": () => new Card("Dropkick+", 1, "Attack", "Deal [DAM8] damage. If the enemy has Vulnerable, gain 1 energy and draw a card.", function(enemy){
                    dealDamage(enemy, 8);
                    if(enemy.hasBuff("Vulnerable") > 0) {
                        energy++;
                        drawCard();
                    }
                }), "Dual Wield": () => new Card("Dual Wield+", 1, "Skill", "Create 2 copies of an Attack or Power card in your hand.", async function(enemy){
                    let chosen = await choose(hand.filter(x=>["Attack","Power"].includes(x.type)), "Choose a card to copy.");
                    if(chosen) {
                        hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use, chosen.flags));
                        hand.push(new Card(chosen.name, chosen.cost, chosen.type, chosen.desc, chosen.use, chosen.flags));
                        updateHtml();
                    } else {
                        alert("Failed to play Dual Wield: No Attack or Power cards in hand.");
                    }
                }), "Entrench": () => new Card("Entrench+", 1, "Skill", "Double your Block.", function(enemy){
                    if(hasBuff("Block")>0) {gainBuff("Block", hasBuff("Block"));}
                }), "Evolve": () => new Card("Evolve+", 1, "Power", "Whenever you draw a Status card, draw 2 more cards.", function(enemy){
                    gainBuff("Evolve", 2);
                }, ["exhausted"]), "Feel No Pain": () => new Card("Feel No Pain+", 1, "Power", "When a card is Exhausted, gain [BLK4] Block.", function(enemy){
                    gainBuff("Feel No Pain", 4);
                }, ["exhausted"]), "Fire Breathing": () => new Card("Fire Breathing+", 1, "Power", "Whenever you draw a Status card, deal 10 damage to ALL enemies", function(enemy){
                    gainBuff("Fire Breathing", 10);
                }, ["exhausted"]), "Flame Barrier": () => new Card("Flame Barrier+", 2, "Skill", "Gain [BLK16] Block and 3 Thorns.", function(enemy){
                    gainBuff("Block", 16); gainBuff("Thorns", 3);
                }), "Ghostly Armor": () => new Card("Ghostly Armor+", 1, "Skill", "Ethereal. Gain [BLK13] Block.", function(enemy){
                    gainBuff("Block", 13);
                }, ["ethereal"]), "Hemokinesis": () => new Card("Hemokinesis+", 1, "Attack", "Lose 2 HP. Deal [DAM20] damage.", function(enemy){
                    hp -= 2; dealDamage(enemy, 20);
                }), "Infernal Blade": () => new Card("Infernal Blade+", 0, "Skill", "Add 2 random Attacks to your hand. Exhaust", function(enemy){
                    let extraCard = randCard()(); // looks weird ik
                    while(extraCard.type != "Attack") {extraCard = randCard()();}
                    hand.push(extraCard);
                    let extraCard2 = randCard()(); // looks weird ik
                    while(extraCard2.type != "Attack") {extraCard2 = randCard()();}
                    hand.push(extraCard2);
                }, ["exhausted"]), "Enflame": () => new Card("Enflame+", 1, "Power", "Gain 3 Strength.", function(enemy){
                    gainBuff("Strength", 3);
                }, ["exhausted"]), "Intimidate": () => new Card("Intimidate+", 0, "Skill", "Apply 2 Weak to ALL enemies. Exhaust.", function(enemy){
                    for(let e of enemies) {e.gainBuff("Weak", 2);}
                }, ["exhausted"]), "Metallicize": () => new Card("Metallicize+", 1, "Power", "Start each turn with [BLK4] Block.", function(enemy){
                    gainBuff("Metallicize", 4);
                }, ["exhausted"]), "Power Through": () => new Card("Power Through+", 1, "Skill", "Add 2 Wounds to your hand. Gain [BLK20] Block.", function(enemy){
                    hand.push(statusCards["Wound"]()); hand.push(statusCards["Wound"]()); gainBuff("Block", 20);
                }), "Pummel": () => new Card("Pummel+", 2, "Attack", "Deal [DAM2] damage 8 times.", function(enemy){
                    dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2); dealDamage(enemy,2);
                }), "Rage": () => new Card("Rage+", 0, "Skill", "For each Attack you play this turn, gain [BLK5] Block.", function(enemy){
                    gainBuff("Rage", 5);
                }), "Rampage": () => new Card("Rampage+", 1, "Attack", "Deal [RAMPAGE] damage. This card deals 8 more damage this combat.", function(enemy){
                    dealDamage(enemy, 8 + hasBuff("Rampage")); gainBuff("Rampage", 8);
                }), "Reckless Charge": () => new Card("Reckless Charge+", 0, "Attack","Deal [DAM10] damage. Get a Dazed card.", function(enemy){
                    dealDamage(enemy, 10); discardPile.push(statusCards["Dazed"]());
                }), "Second Wind": () => new Card("Second Wind+", 1, "Skill", "Exhaust all non-Attack cards in your hand. Gain [BLK7] Block for each card Exhausted.", function(enemy){
                    for(let card of hand) {
                        if(card.type != "Attack") {
                            exhaustPile.push(card);
                            hand.splice(hand.indexOf(card), 1);
                            gainBuff("Block", 7);
                        }
                    }
                }), "Seeing Red": () => new Card("Seeing Red+", 0, "Skill", "Gain 2 energy. Exhaust.", function(enemy){
                    energy += 2;
                }, ["exhausted"]), "Sever Soul": () => new Card("Sever Soul+", 2, "Attack", "Exhaust all non-Attack cards in your hand. Deal [DAM22] damage.", function(enemy){
                    for(let card of hand) {
                        if(card.type != "Attack") {
                            exhaustPile.push(card);
                            hand.splice(hand.indexOf(card), 1);
                        }
                    }
                    dealDamage(enemy, 22);
                }), "Spot Weakness": () => new Card("Spot Weakness+", 1, "Skill", "If the enemy intends to attack, gain 4 Strength.", function(enemy){
                    if(enemy.intent.intent.includes("attack")) {
                        gainBuff("Strength", 4);
                    } else {
                        alert("That enemy does not intend to attack.");
                    }
                }), "Uppercut": () => new Card("Uppercut+", 2, "Attack", "Deal [DAM13] damage. Apply 2 Weak and Vulnerable.", function(enemy){
                    dealDamage(enemy, 13); enemy.gainBuff("Weak", 2); enemy.gainBuff("Vulnerable", 2);
                }), "Whirlwind": () => new Card("Whirlwind+", "X", "Attack", "Deal [DAM8] damage to ALL enemies X times.", function(enemy){
                    for(let e of enemies){dealDamage(e, 8);}
                }), "Barricade": () => new Card("Barricade+", 2, "Power", "Block is not removed at the start of your turn.", function(enemy){
                    gainBuff("Barricade", 1);
                }, ["exhausted"]), "Berserk": () => new Card("Berserk+", 0, "Power", "Gain Vulnerable for 1 turn, but gain 1 more energy each turn.", function(enemy){
                    gainBuff("Vulnerable", 2); gainBuff("Berserk", 1);
                }, ["exhausted"]), "Bludgeon": () => new Card("Bludgeon+", 3, "Attack", "Deal [DAM42] damage.", function(enemy){
                    dealDamage(enemy, 42);
                }), "Brutality": new Card("Brutality+", 0, "Power", "Innate. At the start of your turn, lose 1 HP and draw 1 more card.", function(enemy){
                    gainBuff("Brutality", 1);
                }, ["exhausted", "innate"]), "Demonic Ritual": () => new Card("Demonic Ritual+", 3, "Power", "At the end of your turn, gain 3 Strength.", function(enemy){
                    gainBuff("Ritual", 3);
                }, ["exhausted"]), "Double Tap": () => new Card("Double Tap+", 1, "Skill", "Your next Attack is played 3 times.", function(enemy){
                    gainBuff("Double Tap", 2);
                }, ["exhausted"]), "Exhume": () => new Card("Exhume+", 0, "Skill", "Put a card from your exhaust pile in your hand. Exhaust.", async function(enemy){
                    let chosen = await choose(exhaustPile, "Choose a card to put into your hand.");
                    if(chosen) {
                        hand.push(chosen);
                        exhaustPile.splice(exhaustPile.indexOf(chosen), 1);
                        updateHtml();
                    } else {
                        alert("Failed to play Exhume: Exhaust pile is empty.");
                    }
                }, ["exhausted"]), "Feed": () => new Card("Feed+", 1, "Attack", "Enemy loses 12 HP. If they die from it, gain 4 Max HP. Exhaust.", function(enemy){
                    if(enemy.hp <= 12) {maxHp += 4; hp += 4;}
                    enemy.hp -= 12;
                }, ["exhausted"]), "Impervious": () => new Card("Impervious+", 2, "Skill", "Gain [BLK40] block. Exhaust.", function(enemy){
                    gainBuff("Block", 40);
                }, ["exhausted"]), "Juggernaut": () => new Card("Juggernaut+", 2, "Power", "Whenever you gain Block, deal [DAM7] damage to a random enemy.", function(enemy){
                    gainBuff("Juggernaut", 7);
                }, ["exhausted"]), "Limit Break": () => new Card("Limit Break+", 1, "Skill", "Double your Strength.", function(enemy){
                    if(hasBuff("Strength")>0) {gainBuff("Strength", hasBuff("Strength"));}
                }), "Offering": () => new Card("Offering+", 0, "Skill", "Lose 6 HP. Gain 2 energy. Draw 5 cards. Exhaust.", function(enemy){
                    hp -= 6; energy += 2; drawCard(5);
                }, ["exhausted"]), "Reaper": () => new Card("Reaper+", 2, "Attack", "Deal [DAM10] damage. Heal 10 HP. Exhaust.", function(enemy){
                    dealDamage(enemy, 10); hp = Math.min(maxHp, hp + 10);
                }, ["exhausted"]), "Acrobatics": () => new Card("Acrobatics+", 1, "Skill", "Draw 4 cards. Discard 1 card.", async function(enemy){
                drawCard(4);
                let chosen = await choose(hand.filter(x=>x.name!="Acrobatics+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            }), "Backflip": () => new Card("Backflip+", 1, "Skill", "Gain [BLK8] Block. Draw 2 cards.", function(enemy){
                gainBuff("Block", 8); drawCard(2);
            }), "Bane": () => new Card("Bane+", 1, "Attack", "Deal [DAM10] damage, twice if enemy has Poison.", function(enemy){
                dealDamage(enemy, 10); if(enemy.hasBuff("Poison")) {dealDamage(enemy, 10);}
            }), "Blade Dance": () => new Card("Blade Dance+", 1, "Skill", "Add 4 Shivs to your hand.", function(enemy){
                addShivs(4);
            }), "Cloak and Dagger": () => new Card("Cloak and Dagger+", 1, "Skill", "Gain [BLK6] Block. Add 2 Shivs to your hand.", function(enemy){
                gainBuff("Block", 6); addShivs(2);
            }), "Dagger Spray": () => new Card("Dagger Spray+", 1, "Attack", "Deal [DAM6] damage to ALL enemies twice.", function(enemy){
                for(let e of enemies){dealDamage(e, 6);dealDamage(e, 6);}
            }), "Dagger Throw": () => new Card("Dagger Throw+", 1, "Attack", "Deal [DAM12] damage. Draw a card. Discard a card.", async function(enemy){
                dealDamage(enemy, 12); drawCard(1);
                let chosen = await choose(hand.filter(x=>x.name!="Dagger Throw+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
            }), "Deadly Poison": () => new Card("Deadly Poison+", 1, "Skill", "Apply 7 Poison.", function(enemy){
                enemy.gainBuff("Poison", 7);
            }), "Deflect": () => new Card("Deflect+", 0, "Skill", "Gain [BLK7] Block.", function(enemy){
                gainBuff("Block", 7);
            }), "Dodge and Roll": () => new Card("Dodge and Roll+", 1, "Skill", "Gain [BLK5] Block. Next turn, gain [BLK8] Block.", function(enemy){
                gainBuff("Block", 5); gainBuff("Next Turn Block", 8);
            }), "Flying Knee": () => new Card("Flying Knee+", 1, "Attack", "Deal [DAM11] damage. Gain 1 more energy next turn.", function(enemy){
                dealDamage(enemy, 11); gainBuff("Next Turn Energy", 1);
            }), "Outmaneuver": () => new Card("Outmaneuver+", 1, "Skill", "Gain 3 more energy next turn.", function(enemy){
                gainBuff("Next Turn Energy", 3);
            }), "Poisoned Stab": () => new Card("Poisoned Stab+", 1, "Attack", "Deal [DAM8] damage. Apply 4 Poison.", function(enemy){
                dealDamage(enemy, 8); enemy.gainBuff("Poison", 4);
            }), "Prepared": () => new Card("Prepared+", 0, "Skill", "Draw 2 cards. Discard 2 cards.", async function(enemy){
                drawCard(2);
                let chosen = await choose(hand.filter(x=>x.name!="Prepared+"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared+"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
            }), "Quick Slash": () => new Card("Quick Slash+", 1, "Attack", "Deal [DAM12] damage. Draw a card.", function(enemy){
                dealDamage(enemy, 12); drawCard();
            }), "Slice": () => new Card("Slice+", 0, "Deal [DAM9] damage.", function(enemy){
                dealDamage(enemy, 9);
            }), "Sucker Punch": () => new Card("Sucker Punch+", 1, "Attack", "Deal [DAM9] damage. Apply 2 Weak.", function(enemy){
                dealDamage(enemy, 9); enemy.gainBuff("Weak", 2);
            }), "Accuracy": () => new Card("Accuracy+", 1, "Power", "Shivs deal 6 more damage.", function(enemy){
                gainBuff("Accuracy", 6);
            }, ["exhausted"]), "All-Out Attack": () => new Card("All-Out Attack+", 1, "Attack", "Deal [DAM14] damage to ALL enemies. Discard a random card.", function(enemy){
                for(let e of enemies) {dealDamage(e, 14);}
                let chosen = choice(hand);
                discardPile.push(chosen);
                hand.splice(hand.indexOf(chosen), 1);
            }), "Backstab": () => new Card("Backstab+", 0, "Attack", "Innate. Deal [DAM15] damage. Exhaust.", function(enemy){
                dealDamage(enemy, 15);
            }, ["exhausted", "innate"]), "Blur": () => new Card("Blur+", 1, "Skill", "Gain [BLK8] Block. Block is not removed next turn.", function(enemy){
                gainBuff("Blur", 1); gainBuff("Block", 8);
            }), "Bouncing Flask": () => new Card("Bouncing Flask+", 2, "Skill", "Apply 12 Poison to a random enemy.", function(enemy){
                choice(enemies).gainBuff("Poison", 12);
            }), "Caltrops": () => new Card("Caltrops+", 1, "Skill", "Gain 5 Thorns. Exhaust.", function(enemy){
                gainBuff("Thorns", 5);
            }, ["exhausted"]), "Catalyst": () => new Card("Catalyst+", 1, "Skill", "Triple the enemy's Poison. Exhaust.", function(enemy){
                enemy.gainBuff("Poison", enemy.hasBuff("Poison") * 2);
            }, ["exhausted"]), "Concentrate": () => new Card("Concentrate+", 0, "Skill", "Discard 2 cards. Gain 2 energy.", async function(enemy){
                let chosen = await choose(hand.filter(x=>x.name!="Prepared"), "Choose a card to discard.");
                if(chosen) {
                    discardPile.push(chosen);
                    hand.splice(hand.indexOf(chosen), 1);
                    updateHtml();
                }
                let chosen2 = await choose(hand.filter(x=>x.name!="Prepared"), "Choose another card to discard.");
                if(chosen2) {
                    discardPile.push(chosen2);
                    hand.splice(hand.indexOf(chosen2), 1);
                    updateHtml();
                }
                energy += 2;
            }), "Crippling Cloud": () => new Card("Crippling Cloud+", 2, "Skill", "Apply 7 Poison and 2 Weak to ALL enemies. Exhaust.", function(enemy){
                for(let e of enemies) {e.gainBuff("Poison", 7); e.gainBuff("Weak", 2);}
            }, ["exhausted"]), "Dash": () => new Card("Dash+", 2, "Attack", "Deal 13 damage. Gain 13 Block.", function(enemy){
                gainBuff("Block", 13); dealDamage(enemy, 13);
            }), "Distraction": () => new Card("Distraction+", 0, "Skill", "Add 2 random Skills to your hand. Exhaust.", function(enemy){
                let extraCard = randCard()(); // looks weird ik
                while(extraCard.type != "Skill") {extraCard = randCard()();}
                hand.push(extraCard);
                extraCard = randCard()(); // looks weird ik
                while(extraCard.type != "Skill") {extraCard = randCard()();}
                hand.push(extraCard);
            }, ["exhausted"]), "Escape Plan": () => new Card("Escape Plan+", 0, "Skill", "Draw a card. If it's a Skill, gain 5 Block.", function(enemy){
                drawCard();
                if(hand[hand.length - 1].type == "Skill") {gainBuff("Block", 5);}
            }), "Expertise": () => new Card("Expertise+", 1, "Skill", "Draw cards until you have 7 in hand.", function(enemy){
                if(hand.length < 7) {drawCard(7 - hand.length);}
            }), "Finisher": () => new Card("Finisher+", 1, "Attack", "Deal 8 damage for each Attack played this turn. (Deals [FINISHER+] damage)", function(enemy){
                dealDamage(enemy, stats.attacksThisTurn * 8);
            }), "Footwork": () => new Card("Footwork+", 1, "Power", "Gain 3 Dexterity.", function(enemy){
                gainBuff("Dexterity", 3);
            }, ["exhausted"]), "Heel Hook": () => new Card("Heel Hook+", 1, "Attack", "Deal [DAM8] damage. If the enemy has Weak, gain 1 energy and draw a card.", function(enemy){
                dealDamage(enemy, 8);
                if(enemy.hasBuff("Weak") > 0) {energy += 1; drawCard();}
            }), "Infinite Blades": () => new Card("Infinite Blades+", 1, "Power", "Innate. At the start of your turn, add a Shiv into your hand.", function(enemy){
                gainBuff("Infinite Blades", 1);
            }, ["exhausted", "innate"]), "Leg Sweep": () => new Card("Leg Sweep+", 2, "Skill", "Apply 3 Weak. Gain 14 Block.", function(enemy){
                gainBuff("Block", 14); enemy.gainBuff("Weak", 3);
            }), "Noxious Fumes": () => new Card("Noxious Fumes+", 1, "Power", "At the start of your turn, apply 3 Poison to ALL enemies.", function(enemy){
                gainBuff("Noxious Fumes", 3);
            }, ["exhausted"]), "Predator": () => new Card("Predator+", 2, "Attack", "Deal [DAM20] damage. Next turn, draw 2 more cards.", function(enemy){
                dealDamage(enemy, 2); gainBuff("Next Turn Cards", 2);
            }), "Skewer": () => new Card("Skewer+", "X", "Attack", "Deal [DAM10] damage X times.", function(enemy){
                dealDamage(enemy, 10);
            }), "Terror": () => new Card("Terror+", 0, "Skill", "Apply 999 Vulnerable. Exhaust.", function(enemy){
                enemy.gainBuff("Vulnerable", 999);
            }, ["exhausted"])
            };
            
            function upgradeCard(c) {
                let newCard = upgradedCards[c.name];
                let deckNames = deck.map(x=>x.name);
                deck.splice(deckNames.indexOf(c.name), 1);
                deck.push(newCard());
            }
            let cardToUpgrade;
            async function upgradeDialog() {
                let chosen = await choose(deck.filter(x=>(!x.name.includes("+"))), "Choose a card to upgrade.");
                cardToUpgrade = chosen;
                getId("upgradeDialog").style.display = "block";
                getId("cardDesc").innerHTML = "Upgrading <b>"+cardToUpgrade.name+"</b>:<br/><span style='color:#faa'>Old</span>: "+addCircle(cardToUpgrade.cost.toString())+" | "+unformat(cardToUpgrade.desc)+"<br/><span style='color:#afa'>New</span>: "+addCircle(upgradedCards[cardToUpgrade.name]().cost.toString())+" | "+unformat(upgradedCards[cardToUpgrade.name]().desc);
            }
            
            let randCard = () => choice([bodySlam, clash, cleave, clothesline, flex, headbutt, heavyBlade, ironWave, pommelStrike, shrugItOff, swordBoomerang, thunderclap, trueGrit, twinStrike, wildStrike, battleTrance, bloodForBlood, bloodletting, burningPact, carnage, combust, darkEmbrace, disarm, dropkick, dualWield, entrench, evolve, feelNoPain, fireBreathing, flameBarrier, ghostlyArmor, hemokinesis, infernalBlade, inflame, intimidate, metallicize, powerThrough, pummel, rage, rampage, secondWind, seeingRed, severSoul, spotWeakness, uppercut, whirlwind, acrobatics, backflip, bane, bladeDance, cloakAndDagger, daggerSpray, daggerThrow, deadlyPoison, deflect, dodgeAndRoll, flyingKnee, outmaneuver, poisonedStab, prepared, quickSlash, slice, suckerPunch, accuracy, allOutAttack, backstab, blur, bouncingFlask, caltrops, catalyst, concentrate, cripplingCloud, dash, distraction, expertise, finisher, footwork, heelHook, infiniteBlades, legSweep, noxiousFumes, predator, skewer, terror]);
            let randRareCard = () => choice([barricade, berserk, bludgeon, brutality, demonForm, doubleTap, exhume, feed, impervious, juggernaut, limitBreak, offering, reaper]);
            
            function addCard(newCards="random") {
                if(newCards == "random") {
                    if(eliteBattle == true || bossBattle == true) {
                        newCards = [randRareCard()(), randRareCard()(), randRareCard()()];
                    } else {
                        newCards = [randCard()(), randCard()(), randCard()()];
                    }
                }
                possibleCards = newCards;
                getId("cardModal").style.display = "block";
                for(let x=0; x<3; x++) {
                    let cardTooltip = document.createElement("span");
                    let modalCard = getId("modalCard"+(x+1));
                    modalCard.innerHTML = newCards[x].name;
                    cardTooltip.innerHTML = addCircle(newCards[x].cost.toString())+" "+newCards[x].type+" | "+unformat(newCards[x].desc);
                    cardTooltip.setAttribute("class", "txt");
                    modalCard.appendChild(cardTooltip);
                }
            };
            function finishAddCard(cardNumber) {
                if(cardNumber >= 0 && cardNumber < possibleCards.length) {
                    let c = possibleCards[cardNumber];
                    if(!c || !c.name) {
                        alert("something is broken, the picked card doesn't seem to exist");
                    }
                    if(!c.use) {
                        alert("card added (" + c.name + ") doesn't have a use() function!!");
                    }
                    deck.push(c);
                    for(let r of relics) {if(r.trigger == "add_card") {r.effect(c);}}
                    updateStatLine();
                } else if(cardNumber == -1) {
                    for(let r of relics) {if(r.trigger == "no_card") {r.effect();}}
                    updateStatLine();
                } else {
                    alert("got to impossible place when adding a card");
                }
            }
            
            function addBossRelic(newCards="random") {
                if(newCards == "random") {
                    newCards = [choice(rareRelicPool)(), choice(rareRelicPool)(), choice(rareRelicPool)()];
                }
                possibleCards = newCards;
                getId("bossModal").style.display = "block";
                for(let x=0; x<3; x++) {
                    let cardTooltip = document.createElement("span");
                    let modalCard = getId("modalRelic"+(x+1));
                    modalCard.innerHTML = newCards[x].name;
                    cardTooltip.innerHTML = newCards[x].desc;
                    cardTooltip.setAttribute("class", "txt");
                    modalCard.appendChild(cardTooltip);
                }
            };
            function finishAddRelic(cardNumber) {
                if(cardNumber >= 0 && cardNumber < possibleCards.length) {
                    let r = possibleCards[cardNumber];
                    relics.push(r);
                    if(r.trigger == "on_pickup") {r.effect();}
                    updateStatLine();
                } else {
                    alert("error in logic of adding boss relic");
                }
            }
            let possibleCards = [];
            
            function r_snakeRing() {drawCard(2);}
            function r_akabeko() {gainBuff("Strength", 8); gainBuff("Vigor", 8);}
            function r_anchor() {gainBuff("Next Turn Block", 10);}
            function r_tea() {energy += 2;}
            function r_artOfWar() {gainBuff("Next Turn Energy", 1);}
            function r_bagOfMarbles() {for(let x of enemies){x.gainBuff("Vulnerable",1);}}
            function r_bloodVial() {hp = Math.min(maxHp, hp+2);}
            function r_bronzeScales() {gainBuff("Thorns", 3);}
            function r_ceramicFish() {gold += 9;}
            function r_nunchaku() {if(Math.random()<0.1){energy += 1;}}
            function r_smoothStone() {gainBuff("Dexterity", 1);}
            function r_orichalcum() {if(hasBuff("Block")==0){gainBuff("Block", 6);}}
            function r_penNib() {gainBuff("Pen Nib", 1); if(hasBuff("Pen Nib") >= 10) {loseBuff("Pen Nib"); dealDamage(target, 10);}}
            function r_preservedInsect() {if(eliteBattle==true){dealDamage(target,Math.round(0.25*target.hp));}}
            function r_regalPillow() {hp = Math.min(maxHp, hp+15);}
            function r_strawberry() {maxHp += 7; hp += 7;}
            function r_vajra() {gainBuff("Strength", 1);}
            function r_feather() {hp = Math.min(maxHp, hp+Math.round(0.5*deck.length));}
            function r_frozenEgg(c) {if(c.type=="Power"){upgradeCard(c);}}
            function r_letterOpener() {for(let x of enemies){dealDamage(x, 5);}}
            function r_meatBone() {if(hp/maxHp <= 0.5) {hp = Math.min(maxHp, hp+12);}}
            function r_mercuryHourglass() {for(let x of enemies){dealDamage(x, 3);}}
            function r_moltenEgg(c) {if(c.type=="Attack"){upgradeCard(c);}}
            function r_ornamentalFan() {gainBuff("Block", 4);}
            function r_pear() {maxHp += 10; hp += 10;}
            function r_selfFormingClay() {gainBuff("Next Turn Block", 3);}
            function r_singingBowl() {maxHp += 2; hp += 2;}
            function r_strikeDummy() {dealDamage(target, 3);}
            function r_toxicEgg(c) {if(c.type=="Skill"){upgradeCard(c);}}
            function r_birdFacedUrn() {hp = Math.min(maxHp, hp+2);}
            function r_championsBelt() {target.gainBuff("Weak", 1);}
            function r_deadBranch() {hand.push(randCard()());}
            function r_helixFossil() {gainBuff("Buffer", 1);}
            function r_mango() {maxHp += 14; hp += 14;}
            function r_oldCoin() {gold += 300;}
            function r_threadAndNeedle() {gainBuff("Metallicize", 3);}
            let relicPool = [
                () => new Relic("Akabeko","Your first attack each combat deals 8 more damage.","combat_start",r_akabeko),
                () => new Relic("Anchor","Start each combat with 10 Block","combat_start",r_anchor),
                () => new Relic("Ancient Tea Set","When you enter a Rest Site, start the next combat with 2 more energy.","rest",r_tea),
                () => new Relic("Art of War","If you play no attacks in a turn, gain 1 energy next turn.","no_attacks",r_artOfWar),
                () => new Relic("Bag of Marbles","ALL enemies start combat with 1 Vulnerable.","combat_start",r_bagOfMarbles),
                () => new Relic("Blood Vial","At start of combat, heal 2 HP.","combat_start",r_bloodVial),
                () => new Relic("Bronze Scales","When you take damage, deal 3 damage back.","combat_start",r_bronzeScales),
                () => new Relic("Ceramic Fish","When you add a card to your deck, gain 9 gold.","add_card",r_ceramicFish),
                () => new Relic("Lantern","Gain 1 energy at the start of each combat.","combat_start",r_artOfWar),
                () => new Relic("Nunchaku","When you play an Attack, 10% chance to gain 1 energy.","on_attack",r_nunchaku),
                () => new Relic("Oddly Smooth Stone","Start each combat with 1 Dexterity.","combat_start",r_smoothStone),
                () => new Relic("Orichalcum","When you end your turn without Block, gain 6 Block.","turn_end",r_orichalcum),
                () => new Relic("Pen Nib","Every 10th Attack you play deals 10 more damage.","on_attack",r_penNib),
                () => new Relic("Preserved Insect","Elites have 25% less HP.","combat_start",r_preservedInsect),
                () => new Relic("Regal Pillow","When you leave a Rest Site, heal 15 HP.","rest",r_regalPillow),
                () => new Relic("Strawberry","Raise your max HP by 7 and heal 7 HP.","on_pickup",r_strawberry),
                () => new Relic("Vajra","Start each combat with 1 Strength.","combat_start",r_vajra),
                () => new Relic("Eternal Feather","When you rest, heal 1 HP for each 2 cards in your deck.","rest",r_feather),
                () => new Relic("Frozen Egg","When you add a Power to your deck, it is upgraded.","add_card",r_frozenEgg),
                () => new Relic("Ice Cream","You can keep excess energy between turns.","special",function(){}),
                () => new Relic("Kunai","When you play 3 Attacks in a single turn, gain 1 Dexterity.","3_attacks",r_smoothStone),
                () => new Relic("Letter Opener","When you play 3 Skills in a single turn, deal 5 damage to ALL enemies.","3_skills",r_letterOpener),
                () => new Relic("Meat on the Bone","When you start combat with under 50% HP, heal 12 HP.","combat_start",r_meatBone),
                () => new Relic("Mercury Hourglass","At start of turn, deal 3 damage to ALL enemies.","turn_start",r_mercuryHourglass),
                () => new Relic("Molten Egg","When you add an Attack to your deck, it is upgraded.","add_card",r_moltenEgg),
                () => new Relic("Ornamental Fan","When you play 3 Attacks in a single turn, gain 4 Block.","3_attacks",r_ornamentalFan),
                () => new Relic("Pear","Raise your max HP by 10 and heal 10 HP.","on_pickup",r_pear),
                () => new Relic("Self-Forming Clay","When you lose HP in combat, gain 3 Block next turn.","lose_hp",r_selfFormingClay),
                () => new Relic("Shuriken","When you play 3 Attacks in a single turn, gain 1 Strength.","3_attacks",r_vajra),
                () => new Relic("Singing Bowl","When you view but decline the card reward, gain 2 Max HP.","no_card",r_singingBowl),
                () => new Relic("Strike Dummy","Cards containing 'Strike' deal 3 more damage.","strike",r_strikeDummy),
                () => new Relic("Toxic Egg","When you add a Skill to your deck, it is upgraded.","add_card",r_toxicEgg)
            ];
            let rareRelicPool = [
                () => new Relic("Bird-Faced Urn","When you play a Power, heal 2 HP.","on_power",r_birdFacedUrn),
                () => new Relic("Champion's Belt","When you apply Vulnerable, also apply 1 Weak.","apply_vulnerable",r_championsBelt),
                () => new Relic("Charon's Ashes","When you Exhaust a card, deal 3 damage to ALL enemies.",r_mercuryHourglass),
                () => new Relic("Dead Branch","When you Exhaust a card, add a random card to your hand.","on_exhaust",r_deadBranch),
                () => new Relic("Fossilized Helix","Prevent the first HP loss each combat.","combat_start",r_helixFossil),
                () => new Relic("Mango","Raise your max HP by 14 and heal 14 HP.","on_pickup",r_mango),
                () => new Relic("Old Coin","Instantly gain 300 gold.","on_pickup",r_oldCoin),
                () => new Relic("Thread and Needle","Start each combat with 3 Metallicize.","combat_start",r_threadAndNeedle)
            ];
            
            let potionPool = [
                {name: "Block", desc: "Gain 12 Block.", effect: "gainBuff('Block', 12)"},
                {name: "Blood", desc: "Heal for 20% of your Max HP.", effect: "hp = Math.min(maxHp, hp + Math.round(0.2 * maxHp))"},
                {name: "Cultist", desc: "Gain 1 Ritual.", effect: "gainBuff('Ritual', 1)"},
                {name: "Dexterity", desc: "Gain 2 Dexterity.", effect: "gainBuff('Dexterity', 2)"},
                {name: "Energy", desc: "Gain 2 energy.", effect: "energy += 2"},
                {name: "Iron", desc: "Gain 3 Metallicize.", effect: "gainBuff('Metallicize', 3)"},
                {name: "Explosive", desc: "Deal 10 damage to ALL enemies.", effect: "for(let e of enemies){dealDamage(e, 10);}"},
                {name: "Fear", desc: "Apply 3 Vulnerable to target.", effect: "tgt.gainBuff('Vulnerable', 3)"},
                {name: "Fire", desc: "Deal 20 damage to target.", effect: "dealDamage(tgt, 20)"},
                {name: "Flex", desc: "Gain 5 Strength. At end of turn, lose 5 Strength.", effect: "gainBuff('Strength', 5); gainBuff('Strength Down', 5)"},
                {name: "Fruit Juice", desc: "Gain 5 Max HP.", effect: "maxHp += 5; hp += 5"},
                {name: "Steel", desc: "Gain 5 Metallicize.", effect: "gainBuff('Metallicize', 5)"},
                {name: "Bronze", desc: "Gain 3 Thorns.", effect: "gainBuff('Thorns', 3)"},
                {name: "Regen", desc: "Gain 5 Regen.", effect: "gainBuff('Regen', 5)"},
                {name: "Speed", desc: "Gain 5 Dexterity. At end of turn, lose 5 Dexterity.", effect: "gainBuff('Dexterity', 5); gainBuff('Dexterity Down', 5)"},
            ];
            
            let deck = [strike(), strike(), strike(), strike(), bash(), defend(), defend(), defend(), defend(), defend()];
            let relics = [new Relic("Ring of the Snake","At the start of each combat, draw 2 additional cards.","combat_start",r_snakeRing)];
            let potions = [];
            let drawPile = shuffle(deck.slice(0)); // no shallow copy
            let discardPile = [];
            let exhaustPile = [];
            let hand = [];
            let energy = 0;
            let maxEnergy = 3;
            let hp = 70;
            let maxHp = 70;
            let buffs = [];
            let stats = {timesLostHp: 0, hasAttacked: false, attacksThisTurn: 999, skillsThisTurn: 999, rested: false};
            let gold = 0;
            let mapX = 2;
            let mapY = 0;
            let actNum = 1;
            let randomThing = () => choice(["enemy", "enemy", "enemy", "enemy", "shop&nbsp;", "elite", "rest&nbsp;"]);
            function maybeThing() {if(Math.random()<0.6){return randomThing();}else{return "";}}
            let map;
            function mapGen() {
                map = [
                ["",            "",            "start",       "",            ""          ],
                ["",            randomThing(), randomThing(), randomThing(), ""          ],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                [maybeThing(),  randomThing(), randomThing(), randomThing(), maybeThing()],
                ["",            "rest&nbsp;",  "rest&nbsp;",  "rest&nbsp;",  ""          ],
                ["",            "","<b style='color:red'>BOSS&nbsp;</b>","", ""          ]
            ];
            }
            mapGen();
            
            // These make writing attacks *much* easier.
            let attack = amt => function(me){ me.dealDamage(amt); }
            let block = amt => function(me){ me.gainBuff("Block", amt); }
            let block_random = amt => function(me){ choice(enemies).gainBuff("Block", amt); }
            let buff = (what, amt) => function(me){ me.gainBuff(what, amt); }
            let all_buff = (what, amt) => function(me){ for(let e of enemies){e.gainBuff(what, amt);}}
            let apply = (what, amt) => function(me){ gainBuff(what, amt); }
            let status = (what, amt) => function(me){ for(let x=0; x<amt; x++) {discardPile.push(statusCards[what]());} }
            let multi_apply = (lst) => function(me){ for(let x of lst){gainBuff(x[0], x[1]);} }
            let multi_buff = (lst) => function(me){ for(let x of lst){me.gainBuff(x[0], x[1]);} }
            let attack_block = (atk, blk) => function(me){ me.dealDamage(atk); me.gainBuff("Block", blk); }
            let attack_apply = (atk, what, amt) => function(me){ me.dealDamage(atk); gainBuff(what, amt); }
            let attack_buff = (atk, what, amt) => function(me){ me.dealDamage(atk); me.gainBuff(what, amt); }
            let block_buff = (blk, what, amt) => function(me){ me.gainBuff("Block", blk); me.gainBuff(what, amt); }
            let block_multinerf = (blk, lst) => function(me){ me.gainBuff("Block", blk); for(let x of lst){gainBuff(x[0], x[1]);}}
            let attack_status = (atk, what, amt) => function(me){ for(let x=0; x<amt; x++) {discardPile.push(statusCards[what]());} me.dealDamage(atk); }
            let buff_apply = (b, bamt, n, namt) => function(me){ me.gainBuff(b, bamt); gainBuff(n, namt); }
            
            let possibleEnemies = [
                () => new Enemy("Cultist", 50, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 3)},
                    {intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}
                ], ["no-repeat"]),
                () => new Enemy("Jaw Worm", 40, [
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "attack-block 5", desc: "deal [DAM5] damage and block", effect: attack_block(5, 5)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(6, "Strength", 2)}
                ], ["randomize"]),
                () => new Enemy("Louse", 35, [
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 2)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 2)}
                ], ["randomize"]),
                () => new Enemy("Spike Slime", 45, [
                    {intent: "attack-nerf 9", desc: "deal [DAM9] damage and generate Status cards", effect: attack_status(9, "Slimed", 1)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Frail", 1)}
                ]),
                () => new Enemy("Gremlin", 25, [
                    {intent: "attack-nerf 9", desc: "deal [DAM9] damage and apply a negative effect", effect: attack_apply(9, "Weak", 1)}
                ])
            ];
            let possibleElites = [
                () => new Enemy("Gremlin Nob", 85, [
                    {intent: "buffing +", desc: "gain a <b>powerful buff</b>", effect: buff("Enrage", 2)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-nerf 6", desc: "deal [DAM6] damage and apply a negative effect", effect: attack_apply(6, "Vulnerable", 2)},
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)}
                ], ["no-repeat"]),
                () => new Enemy("Lagavulin", 110, [
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "blocking", desc: "block", effect: block(8)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: multi_apply([["Minus Strength", 1], ["Minus Dexterity", 1]])}
                ])
            ];
            let possibleBosses = [
                () => new Enemy("Slime Boss", 190, [
                    {intent: "meganerf", desc: "generate <b>many Status cards</b>", effect: status("Slimed", 3)},
                    {intent: "unknown", desc: "prepare for a strong attack", effect: function(me){}},
                    {intent: "attacking 35", desc: "deal [DAM35] damage", effect: attack(35)}
                ])
            ];
            let possibleEnemies_act2 = [
                () => new Enemy("Spheric Guardian", 60, [
                    {intent: "block-buff +", desc: "gain <b>multiple buffs</b>", effect: multi_buff([["Barricade", 1], ["Block", 25], ["Artifact", 3]])},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(7, "Frail", 5)},
                    {intent: "attack-block 10", desc: "deal [DAM10] damage and block", effect: attack_block(10, 7)}
                ], ["no-repeat"]),
                () => new Enemy("The Chosen", 95, [
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "meganerf", desc: "apply a <b>powerful negative effect</b>", effect: apply("Hex", 1)},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(7, "Vulnerable", 2)},
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                    {intent: "attacking 12", desc: "deal [DAM18] damage", effect: attack(12)},
                    {intent: "attack-nerf 7", desc: "deal [DAM7] damage and apply a negative effect", effect: attack_apply(10, "Vulnerable", 2)},
                    {intent: "attacking 7", desc: "deal [DAM7] damage", effect: attack(7)},
                    {intent: "nerfing", desc: "apply a negative effect and gain a buff", effect: buff_apply("Strength", 3, "Weak", 3)},
                    {intent: "attacking 12", desc: "deal [DAM18] damage", effect: attack(12)}
                ]),
                () => new Enemy("Shelled Parasite", 70, [
                    {intent: "attack-block 8", desc: "deal [DAM8] damage and block", effect: attack_block(8, 10)},
                    {intent: "attack-block 8", desc: "deal [DAM8] damage and block", effect: attack_block(8, 10)},
                    {intent: "attack-nerf 12", desc: "deal [DAM12] damage and apply a negative effect", effect: attack_apply(12, "Frail", 2)}
                ])
            ];
            let possibleElites_act2 = [
                () => new Enemy("Book of Stabbing", 160, [
                    {intent: "attacking 14", desc: "deal [DAM14] damage", effect: attack(14)},
                    {intent: "attack-buff 8", desc: "deal [DAM8] damage and gain a buff", effect: attack_buff(8, "Strength", 4)},
                    {intent: "attack-buff 8", desc: "deal [DAM8] damage and gain a buff", effect: attack_buff(8, "Strength", 4)}
                ]),
                () => new Enemy("Gremlin Leader", 150, [
                    {intent: "buffing", desc: "buff ALL enemies", effect: all_buff("Strength", 3)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "unknown", desc: "summon allies", effect: function(me){
                        let gremlins = [
                            () => new Enemy("Fat Gremlin", 15, [{intent: "attack-nerf 3", desc: "deal [DAM3] damage and apply a negative effect", effect: attack_apply(3, "Weak", 1)}]),
                            () => new Enemy("Mad Gremlin", 20, [{intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}]),
                            () => new Enemy("Shield Gremlin", 15, [{intent: "attacking 4", desc: "deal [DAM4] damage", effect: attack(4)}, {intent: "blocking", desc: "shield a random enemy", effect: block_random(7)}]),
                            () => new Enemy("Sneaky Gremlin", 10, [{intent: "attacking 6", desc: "deal [DAM6] damage", effect: attack(6)}]),
                            () => new Enemy("Wizard Gremlin", 25, [{intent: "unknown", desc: "charge a powerful attack", effect: function(me){}}, {intent: "unknown", desc: "charge a powerful attack", effect: function(me){}}, {intent: "attacking 17", desc: "deal [DAM17] damage", effect: attack(17)}])
                        ];
                        enemies = [choice(gremlins)(), choice(gremlins)(), ...enemies];
                    }}
                ], ["randomize"])
            ];
            let possibleBosses_act2 = [
                () => new Enemy("The Champ", 530, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Strength", 3)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(15, "Metallicize", 3)},
                    {intent: "meganerf", desc: "apply <b>many negative effects</b>", effect: multi_apply([["Vulnerable", 3], ["Weak", 2], ["Frail", 2]])},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)},
                    {intent: "attacking 16", desc: "deal [DAM16] damage", effect: attack(16)}
                ], ["randomize"])
            ];
            let possibleEnemies_act3 = [
                () => new Enemy("Huge Jaw Worm", 70, [
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(8, "Strength", 2)},
                    {intent: "attacking 10", desc: "deal [DAM10] damage", effect: attack(10)},
                    {intent: "block-buff", desc: "block and gain a buff", effect: block_buff(8, "Strength", 2)},
                    {intent: "attack-block 6", desc: "deal [DAM6] damage and block", effect: attack_block(6, 6)}
                ]),
                () => new Enemy("Spiker", 50, [
                    {intent: "unknown", desc: "summon friends", effect: function(me){
                        enemies = [new Enemy("Exploder", 30, [
                            {intent: "unknown 6", desc: "deal [DAM6] damage and get ready to explode", effect: attack(6)},
                            {intent: "unknown 6", desc: "deal [DAM6] damage and get ready to explode", effect: attack(6)},
                            {intent: "unknown 20", desc: "deal [DAM20] damage and die", effect: function(me){me.dealDamage(20);me.hp=0}}
                        ]),
                        new Enemy("Repulsor", 30, [
                            {intent: "nerfing", desc: "generate Status cards", effect: status("Dazed", 2)}
                        ]), ...enemies];
                    }},
                    {intent: "buffing", desc: "gain a buff", effect: buff("Thorns", 3)}
                ], ["no-repeat"]),
                () => new Enemy("Orb Walker", 90, [
                    {intent: "buffing", desc: "gain a buff", effect: buff("Ritual", 3)},
                    {intent: "attack-nerf 10", desc: "deal [DAM10] damage and generate Status cards", effect: attack_status(10, "Burn", 1)}
                ], ["no-repeat"])
            ];
            let possibleElites_act3 = [
                () => new Enemy("Nemesis", 185, [
                    {intent: "nerfing", desc: "generate Status cards", effect: status("Burn", 2)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "attacking 12", desc: "deal [DAM12] damage", effect: attack(12)},
                    {intent: "attacking 30", desc: "deal [DAM30] damage", effect: attack(30)}
                ], ["randomize"]),
                () => new Enemy("Giant Head", 320, [
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attacking 9", desc: "deal [DAM9] damage", effect: attack(9)},
                    {intent: "nerfing", desc: "apply a negative effect", effect: apply("Weak", 1)},
                    {intent: "attack-buff 21", desc: "deal [DAM21] damage and gain a buff", effect: attack_buff(21, "Strength", 3)}
                ], ["no-repeat"])
            ];
            let possibleBosses_act3 = [
                () => new Enemy("Time Eater", 666, [
                    {intent: "attack-buff 20", desc: "deal [DAM20] damage", effect: attack_buff(20, "Strength", 3)},
                    {intent: "block-nerf", desc: "block and apply negative effects", effect: block_multinerf(18, [["Vulnerable", 2], ["Weak", 1]])},
                    {intent: "attack-nerf 27", desc: "deal [DAM27] damage and apply a negative effect", effect: attack_apply(27, "Draw Reduction", 2)},
                    {intent: "attack-buff 20", desc: "deal [DAM20] damage", effect: attack_buff(20, "Strength", 3)},
                    {intent: "attack-nerf 27", desc: "deal [DAM27] damage and apply a negative effect", effect: attack_apply(27, "Draw Reduction", 2)}
                ], ["randomize"])
            ];
            
            let enemies = [choice(possibleEnemies.slice(0))()];
            let eliteBattle = false;
            let bossBattle = false;
            let target = enemies[0];
            
            function updateStatLine() {
                let statusElemB4 = getId("statusLineB4");
                let deckNumber = getId("deckSize");
                let statusElem = getId("statusLine");
                statusElemB4.innerHTML=(hp<=0.25*maxHp ? "<span style='color: red'>HP: "+hp+"/"+maxHp+"</span>" : "HP: "+hp+"/"+maxHp);
                statusElemB4.innerHTML+=" | "+gold+" gold | Act "+"I".repeat(actNum)+", Floor "+mapY;
                deckNumber.innerHTML=deck.length;
                statusElem.innerHTML="<span id='relics'><b>Relics: </b></span>";
                for(let relic of relics) {
                    let relicElem = document.createElement("span");
                    relicElem.setAttribute("class", "tt");
                    relicElem.innerHTML = " | "+relic.name;
                    let relicTooltip = document.createElement("span");
                    relicTooltip.setAttribute("class", "txt");
                    relicTooltip.innerHTML = relic.desc;
                    relicElem.appendChild(relicTooltip);
                    getId("relics").appendChild(relicElem);
                }
                statusElem.innerHTML+= "<br/><br/><span id='potions'><b>Potions: </b></span>";
                for(let potion of potions) {
                    let potionElem = document.createElement("button");
                    potionElem.setAttribute("class", "tt");
                    potionElem.setAttribute("onclick", `let x = function(tgt) { ${potion.effect} }; x(target); potions.splice(${potions.indexOf(potion)}, 1); updateHtml();`);
                    potionElem.innerHTML = potion.name+" Potion";
                    let potionTooltip = document.createElement("span");
                    potionTooltip.setAttribute("class", "txt");
                    potionTooltip.innerHTML = potion.desc;
                    potionElem.appendChild(potionTooltip);
                    getId("potions").appendChild(potionElem);
                }
                for(let i=0; i<(3-potions.length); i++) {
                    let potionElem = document.createElement("button");
                    potionElem.setAttribute("class", "nonbutton");
                    potionElem.innerHTML = "Empty Slot";
                    getId("potions").appendChild(potionElem);
                }
                if(timerRunning) { currentTimer += Date.now() - beforeTime; }
                beforeTime = Date.now();
                let min = Math.floor(currentTimer/60000).toString();
                let sec = Math.floor(currentTimer%60000/1000).toString();
                let sec_100ths = Math.floor(currentTimer%1000/10).toString();
                statusElem.innerHTML += "&nbsp;&nbsp;&nbsp;<button id=\"timer\" class=\""+(timerRunning?"Skill":"Attack")+"\" onclick=\"if(timerRunning){timerRunning=false;getId('timer').setAttribute('class','Attack');updateStatLine();}else{timerRunning=true;getId('timer').setAttribute('class','Skill');updateStatLine();}\"><span style='text-decoration:underline'>T</span>ime: "+min+":"+sec.padStart(2, "0")+"</button>";
                getId("drawPile").innerHTML = "View Draw <span style='text-decoration:underline'>P</span>ile | <span style='color:white'>"+drawPile.length+"</span>";
                getId("discardPile").innerHTML = "View D<span style='text-decoration:underline'>i</span>scard Pile | <span style='color:white'>"+discardPile.length+"</span>";
                getId("exhaustPile").innerHTML = "View <span style='text-decoration:underline'>E</span>xhaust Pile | <span style='color:white'>"+exhaustPile.length+"</span>";
            }
            let timerRunning = true;
            let currentTimer = 0;
            let beforeTime = Date.now();
            function updateHtml() {
                timerRunning = true;
                updateStatLine();
                if(hasBuff("Strength") > 0 && hasBuff("Minus Strength") > 0) {
                    if(hasBuff("Strength") >= hasBuff("Minus Strength")) {
                        loseBuff("Strength", hasBuff("Minus Strength"));
                        loseBuff("Minus Strength");
                    } else {
                        loseBuff("Minus Strength", hasBuff("Strength"));
                        loseBuff("Strength");
                    }
                }
                if(hasBuff("Dexterity") > 0 && hasBuff("Minus Dexterity") > 0) {
                    if(hasBuff("Dexterity") >= hasBuff("Minus Dexterity")) {
                        loseBuff("Dexterity", hasBuff("Minus Dexterity"));
                        loseBuff("Minus Dexterity");
                    } else {
                        loseBuff("Minus Dexterity", hasBuff("Dexterity"));
                        loseBuff("Dexterity");
                    }
                }
                let energyElem = getId("energy");
                energyElem.innerHTML = energy+"/"+maxEnergy+"<span class='txt'>Energy is used to play cards from your hand.</span>";
                if(energy == 0) {energyElem.style.background = "#884";}
                else {energyElem.style.background = "yellow";}
                
                let playerElem = getId("player");
                playerElem.innerHTML = "<span style='font-size:28px;color:#222;'>0</span>Your Hand ("+hand.length+"):";
                if(buffs.length > 0) {
                    playerElem.innerHTML += " |";
                    for(let x of buffs) {
                        let buffStuff = "";
                        if(["Block", "Vulnerable", "Weak", "Strength", "Dexterity", "Strength Down", "No Draw", "Combust", "Dark Embrace", "Thorns", "Ritual", "Frail", "Minus Strength", "Minus Dexterity", "Evolve", "Pen Nib", "Feel No Pain", "Fire Breathing", "Metallicize", "Rage", "Rampage", "Barricade", "Berserk", "Brutality", "Double Tap", "Juggernaut", "Regen", "Dexterity Down", "Artifact", "Hex", "Draw Reduction", "Buffer", "Next Turn Block", "Vigor", "Next Turn Energy", "Poison", "Accuracy", "Blur", "Infinite Blades", "Noxious Fumes", "Next Turn Cards", "Enrage"].includes(x.name)) {
                            buffStuff += "<img src='StS/"+x.name.toLowerCase().replace(" ","_").replace(" ","_")+".png'>";
                        } else {
                            buffStuff += x.name+" ";
                        }
                        let adjustedDamage = function(n) {
                            let newI = n;
                            if(target.hasBuff("Vulnerable")) {newI = Math.round(newI*1.5);}
                            if(hasBuff("Weak")) {newI = Math.round(newI*0.75);}
                            newI += hasBuff("Strength"); newI -= hasBuff("Minus Strength");
                            if(newI > n) {return "<span style='color:lime'>"+newI+"</span>";}
                            else if(newI < n) {return "<span style='color:#f00'>"+newI+"</span>";}
                            else {return newI;}
                        }
                        let adjustedBlock = function(n) {
                            let blockI = n;
                            if(hasBuff("Frail")) {blockI = Math.round(blockI*0.75);}
                            blockI += hasBuff("Dexterity"); blockI -= hasBuff("Minus Dexterity");
                            if(blockI > n) {return "<span style='color:lime'>"+blockI+"</span>";}
                            else if(blockI < n) {return "<span style='color:#f00'>"+blockI+"</span>";}
                            else {return blockI;}
                        }
                        playerElem.innerHTML += "<span class='tt'>"+buffStuff+(x.name.includes("Minus")?"-":"")+x.amt+"<span class='txt'>"+buffDesc[x.name].replace("[DAMT]", adjustedDamage(x.amt)).replace("[BAMT]", adjustedBlock(x.amt)).replace("[AMT]", x.amt).replace("[s]", (x.amt==1 ? "" : "s")).replace("[es]", (x.amt==1 ? "" : "es"))+"</span></span> ";
                    }
                }
                
                let handElem = getId("hand");
                handElem.innerHTML = "";
                for(let c of hand) {
                    let cardElem = document.createElement("button");
                    let playcard = async () => { await c.play(); }
                    cardElem.onclick = playcard;
                    if(c.flags.includes("unplayable") || energy < c.cost) {cardElem.setAttribute("class", "tt unplayable "+c.type);}
                    else {cardElem.setAttribute("class", "tt "+c.type);}
                    cardElem.innerHTML = c.name;
                    let cardTooltip = document.createElement("span");
                    cardTooltip.setAttribute("class", "txt");
                    
                    let newDesc = c.desc.replace("[BLOCK]", "[DAM"+hasBuff("Block")+"]")
                    .replace("[BLOOD4BLOOD]", 4 - stats.timesLostHp)
                    .replace("[HEAVYBLADE]", "[DAM"+(14+hasBuff("Strength")*2)+"]")
                    .replace("[HEAVYBLADE+]", "[DAM"+(14+hasBuff("Strength")*4)+"]")
                    .replace("[RAMPAGE]", "[DAM"+(8+hasBuff("Rampage"))+"]")
                    .replace("[SHIV]", "[DAM"+(4+hasBuff("Accuracy"))+"]")
                    .replace("[SHIV+]", "[DAM"+(6+hasBuff("Accuracy"))+"]")
                    .replace("[FINISHER]", "[DAM"+(6*stats.attacksThisTurn)+"]")
                    .replace("[FINISHER+]", "[DAM"+(8*stats.attacksThisTurn)+"]");
                    for(let i=1; i<300; i++) {
                        let newI = i;
                        if(target.hasBuff("Vulnerable")) {newI = Math.round(newI*1.5);}
                        if(hasBuff("Weak")) {newI = Math.round(newI*0.75);}
                        if(!hasBuff(c.name)) {newI += hasBuff("Strength"); newI -= hasBuff("Minus Strength");}
                        if(newI > i) {newI = "<span style='color:lime'>"+newI+"</span>";}
                        else if(newI < i) {newI = "<span style='color:#f00'>"+newI+"</span>";}
                        let blockI = i;
                        if(hasBuff("Frail")) {blockI = Math.round(blockI*0.75);}
                        if(!hasBuff(c.name)) {blockI += hasBuff("Dexterity"); blockI -= hasBuff("Minus Dexterity");}
                        if(blockI > i) {blockI = "<span style='color:lime'>"+blockI+"</span>";}
                        else if(blockI < i) {blockI = "<span style='color:#f66'>"+blockI+"</span>";}
                        
                        newDesc = newDesc.replace("[DAM"+i+"]", newI).replace("[BLK"+i+"]", blockI);
                        newDesc = newDesc.replace("[DAM"+i+"]", newI).replace("[BLK"+i+"]", blockI);
                    }
                    cardTooltip.innerHTML = addCircle(c.cost.toString())+" "+c.type+"<br/>"+newDesc;
                    
                    cardElem.appendChild(cardTooltip);
                    handElem.appendChild(cardElem);
                }
                
                let enemiesElem = getId("enemies");
                enemiesElem.innerHTML = "";
                for(let eIndex in enemies) {
                    let e = enemies[eIndex];
                    if(e.hasBuff("Strength") > 0 && e.hasBuff("Minus Strength") > 0) {
                        if(e.hasBuff("Strength") >= e.hasBuff("Minus Strength")) {
                            e.loseBuff("Strength", e.hasBuff("Minus Strength"));
                            e.loseBuff("Minus Strength");
                        } else {
                            e.loseBuff("Minus Strength", e.hasBuff("Strength"));
                            e.loseBuff("Strength");
                        }
                    }
                    let enemyElem = document.createElement("span");
                    enemyElem.setAttribute("class", "tt");
                    let enemyButton = document.createElement("button");
                    enemyButton.setAttribute("id", "enemy_"+e.number);
                    enemyButton.setAttribute("onclick", `target = enemies[${eIndex}]; updateHtml();`);
                    let intentType = e.intent.intent.split(" ")[0];
                    let intentNumber = "";
                    if(e.intent.intent.split(" ")[1]) {
                        if(parseInt(e.intent.intent.split(" ")[1])) {
                            intentNumber = parseInt(e.intent.intent.split(" ")[1]);
                            if(hasBuff("Vulnerable") > 0) {intentNumber = Math.round(intentNumber*1.5);}
                            if(e.hasBuff("Weak") > 0) {intentNumber = Math.round(intentNumber*0.75);}
                            intentNumber += e.hasBuff("Strength");
                            intentNumber -= e.hasBuff("Minus Strength");
                            if(intentNumber >= 20 && e.intent.intent.includes("attacking")) {
                                intentType = "bigattack";
                            }
                        } else {
                            intentNumber = e.intent.intent.split(" ")[1];
                        }
                    }
                    if(e.number == target.number) {
                        enemyButton.setAttribute("class", intentType);
                    } else {
                        enemyButton.setAttribute("class", intentType+" nonbutton");
                    }
                    enemyButton.innerHTML = "<span style='color:white'>"+intentNumber+"</span>&nbsp;"+e.name;
                    enemyElem.appendChild(enemyButton);
                    enemyElem.innerHTML += " HP: "+e.hp+" / "+e.maxHp;
                    if(e.buffs.length > 0) {
                        enemyElem.innerHTML += " |";
                        for(let x of e.buffs) {
                            let buffStuff = "";
                            if(["Block", "Vulnerable", "Weak", "Strength", "Dexterity", "Strength Down", "No Draw", "Combust", "Dark Embrace", "Thorns", "Ritual", "Frail", "Minus Strength", "Minus Dexterity", "Evolve", "Pen Nib", "Feel No Pain", "Fire Breathing", "Metallicize", "Rage", "Rampage", "Barricade", "Berserk", "Brutality", "Double Tap", "Juggernaut", "Regen", "Dexterity Down", "Artifact", "Hex", "Draw Reduction", "Buffer", "Next Turn Block", "Vigor", "Next Turn Energy", "Poison", "Accuracy", "Blur", "Infinite Blades", "Noxious Fumes", "Next Turn Cards", "Enrage"].includes(x.name)) {
                                buffStuff += "<img src='StS/"+x.name.toLowerCase().replace(" ","_").replace(" ","_")+".png'>";
                            } else {
                                buffStuff += x.name+" ";
                            }
                            let adjustedDamage = function(n) {
                                let newI = n;
                                if(hasBuff("Vulnerable")) {newI = Math.round(newI*1.5);}
                                if(e.hasBuff("Weak")) {newI = Math.round(newI*0.75);}
                                newI += e.hasBuff("Strength");
                                newI -= e.hasBuff("Minus Strength");
                                if(newI > n) {return "<span style='color:lime'>"+newI+"</span>";}
                                else if(newI < n) {return "<span style='color:#f00'>"+newI+"</span>";}
                                else {return newI;}
                            }
                            let adjustedBlock = function(n) {
                                let blockI = n;
                                if(e.hasBuff("Frail")) {blockI = Math.round(blockI*0.75);}
                                blockI += e.hasBuff("Dexterity");
                                blockI -= e.hasBuff("Minus Dexterity");
                                if(blockI > n) {return "<span style='color:lime'>"+blockI+"</span>";}
                                else if(blockI < n) {return "<span style='color:#f00'>"+blockI+"</span>";}
                                else {return blockI;}
                            }
                            enemyElem.innerHTML += "<span class='tt'>"+buffStuff+(x.name.includes("Minus")?"-":"")+x.amt+"<span class='txt'>"+buffDesc[x.name].replace("[DAMT]", adjustedDamage(x.amt)).replace("[BAMT]", adjustedBlock(x.amt)).replace("[AMT]", x.amt).replace("[s]", (x.amt==1 ? "" : "s")).replace("[es]", (x.amt==1 ? "" : "es"))+"</span></span> ";
                        }
                    }
                    let enemyTooltip = document.createElement("span");
                    enemyTooltip.setAttribute("class", "txt");
                    let newDesc = e.intent.desc;
                    for(let i=1; i<300; i++) {
                        let newI = i;
                        if(hasBuff("Vulnerable") > 1) {newI = Math.round(newI*1.5);}
                        if(e.hasBuff("Weak") > 0) {newI = Math.round(newI*0.75);}
                        newI += e.hasBuff("Strength");
                        newI -= e.hasBuff("Minus Strength");
                        if(newI > i) {newI = "<span style='color:lime'>"+newI+"</span>";}
                        else if(newI < i) {newI = "<span style='color:#f00'>"+newI+"</span>";}
                        newDesc = newDesc.replace("[DAM"+i+"]", newI);
                    }
                    enemyTooltip.innerHTML = e.name+" intends to "+newDesc+".";
                    enemyTooltip.innerHTML += e.buffs.length ? ("<br/>" + e.buffs.map(x => x.name+" "+x.amt+" ("+buffDesc[x.name].replace("[AMT]", x.amt).replace("[s]", (x.amt==1 ? "" : "s")).replace("[es]", (x.amt==1 ? "" : "es"))+")").join("<br/>")) : "";
                    enemyElem.appendChild(enemyTooltip);
                    enemiesElem.appendChild(enemyElem);
                    enemiesElem.appendChild(document.createElement("br"));
                }
                if(enemies.filter(x => x.hp <= 0).length > 0) {
                    enemies = enemies.filter(x => x.hp > 0);
                    updateHtml();
                }
                if(!enemies.includes(target) || !target) {target = enemies[0];}
                if(enemies.length == 0) {
                    getId("rewardsScreen").style.display = "block";
                    getId("goldReward").style.display = "block";
                    getId("cardReward").style.display = "block";
                    getId("gameScreen").style.display = "none";
                    let goldAmt = Math.round(Math.random()*10)+25;
                    getId("goldReward").innerHTML = goldAmt+" gold";
                    getId("goldReward").setAttribute("onclick", `gold += ${goldAmt}; updateStatLine(); getId('goldReward').style.display = 'none';`);
                    if(Math.random() < 0.5) { // set to 1 (always drop) for testing
                        getId("potionReward").style.display = "block";
                        let potionDrop = choice(potionPool);
                        getId("potionReward").innerHTML = potionDrop.name+" Potion";
                        getId("potionReward").setAttribute("onclick", `if(potions.length < 3){potions.push({name: "${potionDrop.name}", desc: "${potionDrop.desc}", effect: "${potionDrop.effect}"}); updateStatLine(); getId('potionReward').style.display = 'none';}`);
                    } else {
                        getId("potionReward").style.display = "none";
                    }
                    if(eliteBattle == true) {
                        getId("relicReward").style.display = "block";
                        let newRelic = choice(relicPool)();
                        getId("relicReward").innerHTML = newRelic.name+"<span class='txt'>"+newRelic.desc+"</span>";
                        getId("relicReward").setAttribute("onclick", `let r = new Relic('${newRelic.name}', '${newRelic.desc}', '${newRelic.trigger}', ${newRelic.use}); relics.push(r); if(r.trigger=='on_pickup') {r.effect();} updateStatLine(); getId('relicReward').style.display = 'none';`);
                    } else {
                        getId("relicReward").style.display = "none";
                    }
                    if(bossBattle == true) {
                        getId("bossRelicReward").style.display = "block";
                        getId("bossRelicReward").innerHTML = "Choose a Relic";
                        getId("bossRelicReward").setAttribute("onclick", "addBossRelic('random'); getId('bossRelicReward').style.display = 'none';");
                    } else {
                        getId("bossRelicReward").style.display = "none";
                    }
                }
                if(hp <= 0) {
                    hp = 0;
                    alert("You died! D:\nReload to try again");
                    getId("gameScreen").style.display = "none";
                }
                let x = document.getElementsByClassName("txt");
                for (t of x) {
                    t.style.left = (mousex+10) + "px";
                    t.style.top = (mousey+10+window.pageYOffset) + "px";
                }
            }
            
            function addShivs(num=1) {
                for(let i=0; i<num; i++) {
                    hand.push(new Card("Shiv", 0, "Attack", "Deal [SHIV] damage. Exhaust.", function(e){dealDamage(e,4,true);}, ["exhausted"]));
                }
            }
            function addShivPluses(num=1) {
                for(let i=0; i<num; i++) {
                    hand.push(new Card("Shiv+", 0, "Attack", "Deal [SHIV+] damage. Exhaust.", function(e){dealDamage(e,6,true);}, ["exhausted"]));
                }
            }
            
            function drawCard(num=1) {
                if(hasBuff("No Draw") > 0) {num=0;}
                for(let x=0; x<num; x++) {
                    if(drawPile.length <= 0) {
                        drawPile = shuffle(discardPile);
                        discardPile = [];
                    }
                    if(drawPile.length > 0 && hand.length < 10) {
                        let toDraw = drawPile.pop(0);
                        hand.push(toDraw);
                        if(toDraw.type == "Status") {
                            drawCard(hasBuff("Evolve"));
                            for(let e of enemies) {
                                dealDamage(e, hasBuff("Fire Breathing"));
                            }
                        }
                    }
                }
            }
            
            function startTurn() {
                if(hasBuff("Draw Reduction") > 0) {
                    drawCard(4); loseBuff("Draw Reduction", 1);
                } else {
                    drawCard(5 + hasBuff("Next Turn Cards"));
                    loseBuff("Next Turn Cards");
                }
                if(hasBuff("Infinite Blades") > 0) {addShivs(hasBuff("Infinite Blades"));}
                for(let relic of relics) {
                    if(relic.name == "Ice Cream") {
                        gainBuff("Next Turn Energy", energy);
                    }
                }
                energy = maxEnergy + hasBuff("Berserk") + hasBuff("Next Turn Energy");
                loseBuff("Next Turn Energy");
                if(stats.attacksThisTurn == 0) {
                    for(let relic of relics) {if(relic.trigger == "no_attacks") {relic.effect();}}
                }
                if(stats.rested == true) {
                    stats.rested = false;
                    for(let relic of relics) {if(relic.trigger == "rest") {relic.effect();}}
                }
                for(let r of relics) {if(r.trigger == "turn_start") {r.effect();}}
                stats.attacksThisTurn = 0;
                stats.skillsThisTurn = 0;
                if(hasBuff("Barricade")==0 && hasBuff("Blur")==0){loseBuff("Block");}
                loseBuff("Blur", 1);
                if(hasBuff("Metallicize")>0){gainBuff("Block", hasBuff("Metallicize"));}
                if(hasBuff("Next Turn Block")>0){gainBuff("Block", hasBuff("Next Turn Block")); loseBuff("Next Turn Block");}
                if(hasBuff("Brutality")>0){hp -= 1; drawCard(hasBuff("Brutality"));}
                if(hasBuff("Poison")>0) {hp -= hasBuff("Poison"); loseBuff("Poison", 1);}
                if(hasBuff("Noxious Fumes")>0){for(let e of enemies){e.gainBuff("Poison", hasBuff("Noxious Fumes"));}}
                updateHtml();
            }
            
            function endTurn() {
                for(let c of hand) {
                    if(c.flags.includes("ethereal")) {exhaustPile.push(c);}
                    else {discardPile.push(c);}
                    if(c.flags.includes("burning")) {hp -= 1;}
                }
                for(let r of relics) {if(r.trigger == "turn_end") {r.effect();}}
                hand = [];
                if(hasBuff("Combust") > 0) {
                    hp -= 1;
                    for(let e of enemies) {dealDamage(e, hasBuff("Combust"));}
                }
                loseBuff("Vulnerable", 1);
                loseBuff("Weak", 1);
                loseBuff("Frail", 1);
                loseBuff("No Draw", 1);
                hp = Math.min(maxHp, hp + hasBuff("Regen"));
                loseBuff("Regen", 1);
                loseBuff("Rage");
                gainBuff("Strength", hasBuff("Ritual"));
                loseBuff("Strength", hasBuff("Strength Down"));
                loseBuff("Strength Down");
                loseBuff("Dexterity", hasBuff("Dexterity Down"));
                loseBuff("Dexterity Down");
                updateHtml();
                for(let e of enemies) {
                    if(e.hasBuff("Barricade")==0){e.loseBuff("Block");}
                    if(e.hasBuff("Metallicize")>0){e.gainBuff("Block", e.hasBuff("Metallicize"));}
                    if(e.hasBuff("Poison")>0) {e.hp -= e.hasBuff("Poison"); e.loseBuff("Poison", 1);}
                    if(e.hp > 0){e.attack();}
                    e.loseBuff("Vulnerable", 1);
                    e.loseBuff("Weak", 1);
                    e.hp = Math.min(e.maxHp, e.hp + e.hasBuff("Regen"));
                    e.loseBuff("Regen", 1);
                    e.gainBuff("Strength", e.hasBuff("Ritual"));
                    e.loseBuff("Strength", e.hasBuff("Strength Down"));
                    e.loseBuff("Strength Down");
                    e.loseBuff("Dexterity", e.hasBuff("Dexterity Down"));
                    e.loseBuff("Dexterity Down");
                }
                startTurn();
            }
            window.setInterval(updateStatLine, 300);
        </script>
    </body>
</html>
